<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
        <title>Michal Zimmermann | tag: postgresql</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link href="https://www.zimmi.cz/posts/atom.xml" type="application/atom+xml" rel="alternate" title="Michal Zimmermann Full Atom Feed" />
        <link href="https://www.zimmi.cz/posts/feed.xml" type="application/rss+xml" rel="alternate" title="Michal Zimmermann Full RSS Feed" />
        <link rel="stylesheet" href="https://www.zimmi.cz/posts/theme/css/style.min.css?d5d1e141">
<!-- Start of Async Drift Code -->
<script>
    !function () {
        var t;
        if (t = window.driftt = window.drift = window.driftt || [], !t.init) return t.invoked ? void (window.console && console.error && console.error("Drift snippet included twice.")) : (t.invoked = !0,
            t.methods = ["identify", "config", "track", "reset", "debug", "show", "ping", "page", "hide", "off", "on"],
            t.factory = function (e) {
                return function () {
                    var n;
                    return n = Array.prototype.slice.call(arguments), n.unshift(e), t.push(n), t;
                };
            }, t.methods.forEach(function (e) {
                t[e] = t.factory(e);
            }), t.load = function (t) {
                var e, n, o, i;
                e = 3e5, i = Math.ceil(new Date() / e) * e, o = document.createElement("script"),
                    o.type = "text/javascript", o.async = !0, o.crossorigin = "anonymous", o.src = "https://js.driftt.com/include/" + i + "/" + t + ".js",
                    n = document.getElementsByTagName("script")[0], n.parentNode.insertBefore(o, n);
            });
    }();
    drift.SNIPPET_VERSION = '0.3.1';
    drift.load('caacyauy5t6b');

</script>
<!-- End of Async Drift Code --></head>

<body id="index" class="home">
    <nav class="top-bar card-1" data-topbar role="navigation">
        <ul class="title-area">
            <li class="name">
                <h1><a href="/posts">Home</a></h1>
            </li>
     <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
            <li class="toggle-topbar menu-icon"><a href="#"><span></span></a></li>
        </ul>
        <section class="top-bar-section">
    <!-- Right Nav Section -->
            <ul class="right">
                <li><a href="https://www.zimmi.cz/posts/categories">Categories</a></li>
                <li><a href="https://www.zimmi.cz/posts/tags">Tags</a></li>
                <li><a href="https://www.zimmi.cz/posts/feed.xml">RSS feed</a></li>
            </ul>
        </section>
    </nav>
        <div class="row">
          <div class="large-12 columns header">
            <h1><a href="/posts">Michal Zimmermann</a> <small>Pieces of knowledge from the world of GIS.</small></h1>
          </div>
        </div>
        <div class="row">
            <div class="large-12 columns">
<h2 class="text-center">Articles tagged with postgresql tag</h2>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2017/upgrading-postgresql-95-to-postgresql-96-with-postgis/" rel="bookmark" title="Permalink to Upgrading PostgreSQL 9.5 to PostgreSQL 9.6 with PostGIS">Upgrading PostgreSQL 9.5 to PostgreSQL 9.6 with&nbsp;PostGIS</a></h1>
            <small>Written on Mar 1, 2017
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Thanks to <code>pg_upgrade</code> tool the PostgreSQL upgrade on Ubuntu is pretty straightforward. Different PostGIS versions might cause troubles though. This post covers PostgreSQL 9.5, PostGIS 2.2 to PostgreSQL 9.6, PostGIS 2.3&nbsp;migration.</p>
<p>First of all, install the PostgreSQL 9.6 with PostGIS&nbsp;2.3.</p>
<div class="highlight"><pre><span></span>apt install postgresql-9.6 postgresql-9.6-postgis-2.3
</pre></div>


<p>Mind that newly installed database cluster runs on port <code>5433</code>.</p>
<p>If you run <code>pg_upgrade</code> at this stage, it will fail with the following&nbsp;error.</p>
<div class="highlight"><pre><span></span>could not load library <span class="s2">&quot;</span><span class="nv">$libdir</span><span class="s2">/postgis_topology-2.2&quot;</span>:
ERROR:  could not access file <span class="s2">&quot;</span><span class="nv">$libdir</span><span class="s2">/postgis_topology-2.2&quot;</span>: No such file or directory
</pre></div>


<p><code>pg_upgrade</code> can&#8217;t run the upgrade because PostGIS versions don&#8217;t match. Install the PostGIS 2.3 for PostgreSQL 9.5 and update extensions in all your&nbsp;databases.</p>
<div class="highlight"><pre><span></span>apt install postgresql-9.5-postgis-2.3

:::sql
ALTER EXTENSION postgis UPDATE<span class="p">;</span>
</pre></div>


<p>With both clusters using the same PostGIS version, the upgrade can begin. First, stop them&nbsp;with</p>
<div class="highlight"><pre><span></span>service postgresql stop
</pre></div>


<p>Then, run the actual <code>pg_upgrade</code> command as <code>postgres</code> user. Make sure the <code>pg_hba.conf</code> file is set to allow local&nbsp;connections.</p>
<div class="highlight"><pre><span></span>/usr/lib/postgresql/9.6/bin/pg_upgrade <span class="se">\</span>
-b /usr/lib/postgresql/9.5/bin/ <span class="se">\</span>
-B /usr/lib/postgresql/9.6/bin/ <span class="se">\</span>
-d /var/lib/postgresql/9.5/main <span class="se">\</span>
-D /var/lib/postgresql/9.6/main <span class="se">\</span>
-o <span class="s1">&#39; -c config_file=/etc/postgresql/9.5/main/postgresql.conf&#39;</span> <span class="se">\</span>
-O <span class="s1">&#39; -c config_file=/etc/postgresql/9.6/main/postgresql.conf&#39;</span>
</pre></div>


<p>The following result means the upgrade was&nbsp;smooth.</p>
<div class="highlight"><pre><span></span>Performing Consistency Checks
-----------------------------
Checking cluster versions                                   ok
Checking database user is the install user                  ok
Checking database connection settings                       ok
Checking <span class="k">for</span> prepared transactions                          ok
Checking <span class="k">for</span> reg* system OID user data types                ok
Checking <span class="k">for</span> contrib/isn with bigint-passing mismatch       ok
Checking <span class="k">for</span> roles starting with <span class="s1">&#39;pg_&#39;</span>                      ok
Creating dump of global objects                             ok
Creating dump of database schemas
                                                            ok
Checking <span class="k">for</span> presence of required libraries                 ok
Checking database user is the install user                  ok
Checking <span class="k">for</span> prepared transactions                          ok

If pg_upgrade fails after this point, you must re-initdb the
new cluster before continuing.

Performing Upgrade
------------------
Analyzing all rows in the new cluster                       ok
Freezing all rows on the new cluster                        ok
Deleting files from new pg_clog                             ok
Copying old pg_clog to new server                           ok
Setting next transaction ID and epoch <span class="k">for</span> new cluster       ok
Deleting files from new pg_multixact/offsets                ok
Copying old pg_multixact/offsets to new server              ok
Deleting files from new pg_multixact/members                ok
Copying old pg_multixact/members to new server              ok
Setting next multixact ID and offset <span class="k">for</span> new cluster        ok
Resetting WAL archives                                      ok
Setting frozenxid and minmxid counters in new cluster       ok
Restoring global objects in the new cluster                 ok
Restoring database schemas in the new cluster
                                                            ok
Copying user relation files
                                                            ok
Setting next OID <span class="k">for</span> new cluster                            ok
Sync data directory to disk                                 ok
Creating script to analyze new cluster                      ok
Creating script to delete old cluster                       ok

Upgrade Complete
----------------
Optimizer statistics are not transferred by pg_upgrade so,
once you start the new server, consider running:
    ./analyze_new_cluster.sh

Running this script will delete the old cluster<span class="err">&#39;</span>s data files:
    ./delete_old_cluster.sh
</pre></div>


<p>The old cluster can be removed and the new one switched back to port <code>5432</code>. Run <code>/usr/lib/postgresql/9.6/bin/vacuumdb -p 5433 --all --analyze-in-stages</code> to collect&nbsp;statistics.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2017/executing-dynamic-sql-query-right-away/" rel="bookmark" title="Permalink to Executing dynamic SQL query right away">Executing dynamic <span class="caps">SQL</span> query right&nbsp;away</a></h1>
            <small>Written on Feb 28, 2017
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>PostgreSQL 9.6 comes with a handy <code>psql</code> command called <code>\gexec</code> that <em>sends the current query input buffer to the server and treats the result as a <span class="caps">SQL</span> statement to be executed</em> (right, whatever). What that means is that instead of doing&nbsp;this</p>
<div class="highlight"><pre><span></span>psql -c <span class="s2">&quot;SELECT &#39;DROP TABLE &#39; || tablename FROM information_schema.tables WHERE table_name LIKE &#39;%to_be_dropped%&quot;</span> <span class="p">|</span> psql
</pre></div>


<p>you&#8217;ll do&nbsp;that</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="s1">&#39;DROP TABLE &#39;</span> <span class="o">||</span> <span class="n">tablename</span> <span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">tables</span> <span class="k">WHERE</span> <span class="k">table_name</span> <span class="k">LIKE</span> <span class="s1">&#39;%to_be_dropped%&#39;</span><span class="err">\</span><span class="n">gexec</span>
</pre></div>


<p>Brilliant.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2017/subdivide-and-conquer-effective-spatial-indexes-in-postgis/" rel="bookmark" title="Permalink to Subdivide and Conquer: Effective Spatial Indexes in PostGIS">Subdivide and Conquer: Effective Spatial Indexes in&nbsp;PostGIS</a></h1>
            <small>Written on Jan 10, 2017
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Spatial indexes are absolutely crucial part of any spatial database and - as I tend to say quite often - only a fool would try to query spatial data without building spatial indexes&nbsp;beforehand.</p>
<p>Spatial indexes are based on bounding box comparisons, which are generally very fast. Yet, there are situations when spatial indexes don&#8217;t help much (or they don&#8217;t help as much as they could, if you&nbsp;wish).</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/subdivide-and-conquer-effective-spatial-indexes-in-postgis/index.svg" /></div>

<p>Bounding box comparisons are effective with lots of small bounding boxes rather then few large ones. Why? See the picture above. The curved line (imagine it&#8217;s a pipeline for example) clearly demonstrates when the spatial index/bounding box comparison might fall short of what you&#8217;d&nbsp;expect.</p>
<p>Once the bounding box gets really big, it intersects so many other geometries&#8217; bounding boxes that the whole comparison starts to slow&nbsp;down.</p>
<p>Luckily, PostGIS 2.2 introduced a <a href="http://postgis.net/docs/ST_Subdivide.html">ST_Subdivide</a> function that can lend a helping hand in&nbsp;here.</p>
<p>Until today, we delivered the parcel geometries into our <a href="https://www.symap.cz">real estate acquisition process system</a> with the following query, that takes all the geometries from the <code>req_geom</code> table (pipelines, remember?) and intersects them with cadastral parcels. The second part of the query adds those parcels that haven&#8217;t been digitalized and were created manually by one of my&nbsp;workmates.</p>
<div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
<span class="k">SELECT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="n">par_id</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
    <span class="n">req_geom</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">JOIN</span>
    <span class="n">pargeo</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span>
 <span class="k">UNION</span>
 <span class="k">SELECT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">idpar</span><span class="p">::</span><span class="nb">numeric</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
     <span class="n">req_man</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">);</span>
</pre></div>


<p>It&#8217;s a perfectly standard query that intersects several request geometries with ~20M parcels, nothing really fancy. Except that it takes 25 minutes to finish. Why? Pipelines,&nbsp;remember?</p>
<p>Yet, the query below takes only 30 seconds to finish (that&#8217;s a huge time saver considering that the whole process used to take ~40 minutes)! Why? Because the <code>ST_Subdivide</code> effectively shrinks the <code>req_geom</code> geometries until they have 50 vertices each at most. Such small geometries are perfect input for the bounding box comparison. Remember to call <code>DISTINCT</code> when using <code>ST_Subdivide</code>, you&#8217;d probably get duplicate parcel ids&nbsp;otherwise.</p>
<p>I also replaced the <code>UNION</code> with the <a href="https://www.zimmi.cz/posts/2015/postgresql-in-vs-exists/"><code>WHERE NOT EXISTS</code></a> expression, as it&#8217;s reasonable to assume that numeric ids comparison will be&nbsp;faster.</p>
<div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="k">DISTINCT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="n">par_id</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
    <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">uid</span><span class="p">,</span>
            <span class="n">ST_Subdivide</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="n">geom</span>
        <span class="k">FROM</span>
            <span class="n">req_geom</span>
     <span class="p">)</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">JOIN</span>
     <span class="n">pargeo</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">geom</span><span class="p">));</span>

 <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
 <span class="k">SELECT</span>
     <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
     <span class="n">a</span><span class="p">.</span><span class="n">idpar</span><span class="p">::</span><span class="nb">numeric</span>
 <span class="k">FROM</span>
     <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
     <span class="n">req_man</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">WHERE</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="p">(</span>
     <span class="k">SELECT</span> <span class="mi">1</span>
     <span class="k">FROM</span> <span class="n">pozadovane_parcely</span> <span class="n">pp</span>
     <span class="k">WHERE</span> <span class="n">pp</span><span class="p">.</span><span class="n">par_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">idpar</span>
  <span class="p">);</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/counting-substring-occurrences-in-postgresql/" rel="bookmark" title="Permalink to Counting substring occurrences in PostgreSQL">Counting substring occurrences in&nbsp;PostgreSQL</a></h1>
            <small>Written on Dec 19, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>I got to count occurrences of <em>/</em> character today and found out no built-in function exists in PostgreSQL, so here&#8217;s my shot at it. Pretty simple, yet&nbsp;useful.</p>
<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">how_many</span><span class="p">(</span><span class="k">IN</span> <span class="nb">text</span><span class="p">,</span> <span class="k">IN</span> <span class="nb">varchar</span><span class="p">,</span> <span class="k">OUT</span> <span class="nb">integer</span><span class="p">)</span>
<span class="k">RETURNS</span> <span class="nb">integer</span>
<span class="k">AS</span>
<span class="err">$</span><span class="n">how_many$</span>
    <span class="k">SELECT</span> <span class="k">length</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="k">length</span><span class="p">(</span><span class="k">replace</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">));</span>
<span class="err">$</span><span class="n">how_many$</span>
<span class="k">LANGUAGE</span> <span class="k">SQL</span>
<span class="k">SECURITY</span> <span class="k">DEFINER</span><span class="p">;</span>

<span class="c1">-- SELECT how_many(&#39;test&#39;, &#39;t&#39;); -- returns number 2</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-load-part-iii/" rel="bookmark" title="Permalink to Plotting the Czech Cadastre Land Use with d3: Data Load (part III)">Plotting the Czech Cadastre Land Use with d3: Data Load (part <span class="caps">III</span>)</a></h1>
            <small>Written on Nov 15, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/d3.html">d3</a>,         <a href="https://www.zimmi.cz/posts/tag/javascript.html">javascript</a>,         <a href="https://www.zimmi.cz/posts/tag/svg.html">svg</a>        | <a href="https://www.zimmi.cz/posts/category/data.html">data</a>
        </small>
        <section>
            <p>This post is the third part of the series summarizing the process of visualizing landuse data with bash, PostgreSQL and d3.js. Read other&nbsp;parts:</p>
<ol>
<li><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-extraction-part-i">Plotting the Czech Cadastre Land Use with d3: Data Extraction (part&nbsp;I)</a></li>
<li><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-transformation-part-ii">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">II</span>)</a></li>
<li>you&#8217;re reading it&nbsp;now</li>
</ol>
<h2><span class="caps">ETL</span>&nbsp;process</h2>
<p>Before the d3 viz can be crafted, it&#8217;s necessary&nbsp;to:</p>
<ol>
<li>extract <span class="caps">CSV</span> data from the URLs provided via the Atom&nbsp;feed</li>
<li>transform those data into a relational database, do some&nbsp;math</li>
<li>load data into a d3.js&nbsp;viz</li>
<li>profit (as&nbsp;usual)</li>
</ol>
<h3>Extract</h3>
<p>See <a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-extraction-part-i">Plotting the Czech Cadastre Land Use with d3: Data Extraction (part I)</a>.</p>
<h3>Transform</h3>
<p>See <a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-transformation-part-ii">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">II</span>)</a>.</p>
<h2>Load</h2>
<p>Thanks to the way I transformed the data, the whole load is done with&nbsp;simple</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

touch ./data/data.js
<span class="nb">echo</span> <span class="s2">&quot;let data =&quot;</span> &gt; ./data/data.js

<span class="o">(</span>
cat <span class="s">&lt;&lt; EOF | psql -qAt --no-psqlrc</span>
<span class="s">    SELECT</span>
<span class="s">    array_to_json(array_agg(row_to_json(r)))</span>
<span class="s">    FROM (</span>
<span class="s">    SELECT *</span>
<span class="s">    FROM data</span>
<span class="s">    ) r</span>
<span class="s">EOF</span>
<span class="o">)</span> &gt;&gt; ./data/data.js
</pre></div>


<p>That&#8217;s the whole <span class="caps">ETL</span> process! Next time, I&#8217;ll cover the d3.js&nbsp;viz.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-transformation-part-ii" rel="bookmark" title="Permalink to Plotting the Czech Cadastre Land Use with d3: Data Transformation (part II)">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">II</span>)</a></h1>
            <small>Written on Nov 14, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/javascript.html">javascript</a>,         <a href="https://www.zimmi.cz/posts/tag/d3.html">d3</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/svg.html">svg</a>        | <a href="https://www.zimmi.cz/posts/category/data.html">data</a>
        </small>
        <section>
            <p>This post is the second part of the series summarizing the process of visualizing landuse data with bash, PostgreSQL and d3.js. Read other&nbsp;parts:</p>
<ol>
<li><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-extraction-part-i">Plotting the Czech Cadastre Land Use with d3: Data Extraction (part&nbsp;I)</a></li>
<li>you&#8217;re reading it&nbsp;now</li>
<li><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-load-part-iii/">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">III</span>)</a></li>
</ol>
<h2><span class="caps">ETL</span>&nbsp;process</h2>
<p>Before the d3 viz can be crafted, it&#8217;s necessary&nbsp;to:</p>
<ol>
<li>extract <span class="caps">CSV</span> data from the URLs provided via the Atom&nbsp;feed</li>
<li>transform those data into a relational database, do some&nbsp;math</li>
<li>load data into a d3.js&nbsp;viz</li>
<li>profit (as&nbsp;usual)</li>
</ol>
<h3>Extract</h3>
<p>See <a href="{filename}../2016/plotting-czech-cadastre-landuse-with-d3-part-i.md">Plotting the Czech Cadastre Land Use with d3: Data Extraction (part I)</a>.</p>
<h3>Transform</h3>
<p>Last time, I extracted the data from multiple <span class="caps">CSV</span> files to separate PostgreSQL tables named by <code>data_YYYYMMDD</code> pattern. My current goal is to transform it into the one big <code>data</code> table, where each row represents one cadastral area. Here&#8217;s what I&#8217;m trying to&nbsp;achieve:</p>
<div class="highlight"><pre><span></span>-<span class="o">[</span> RECORD <span class="m">1</span> <span class="o">]</span>----------+----------------------------------
ku_kod                 <span class="p">|</span> <span class="m">600881</span>
ku_nazev               <span class="p">|</span> Bantice
celkova_vymera         <span class="p">|</span> <span class="o">{</span><span class="m">3763255</span>,3763255,3763256,3763256<span class="o">}</span>
celkovy_pocet_parcel   <span class="p">|</span> <span class="o">{</span><span class="m">670</span>,668,664,667<span class="o">}</span>
chmelnice_pp           <span class="p">|</span> <span class="o">{</span><span class="m">0</span>,0,0,0<span class="o">}</span>
chmelnice_pp_r         <span class="p">|</span> <span class="o">{</span><span class="m">0</span>.00,0.00,0.00,0.00<span class="o">}</span>
chmelnice_v            <span class="p">|</span> <span class="o">{</span><span class="m">0</span>,0,0,0<span class="o">}</span>
chmelnice_v_avg        <span class="p">|</span> <span class="o">{</span><span class="m">0</span>,0,0,0<span class="o">}</span>
chmelnice_v_r          <span class="p">|</span> <span class="o">{</span><span class="m">0</span>.00,0.00,0.00,0.00<span class="o">}</span>
lesni_pozemek_pp       <span class="p">|</span> <span class="o">{</span><span class="m">25</span>,25,25,25<span class="o">}</span>
lesni_pozemek_pp_r     <span class="p">|</span> <span class="o">{</span><span class="m">3</span>.73,3.74,3.77,3.75<span class="o">}</span>
lesni_pozemek_v        <span class="p">|</span> <span class="o">{</span><span class="m">83879</span>,83879,83879,83879<span class="o">}</span>
lesni_pozemek_v_avg    <span class="p">|</span> <span class="o">{</span><span class="m">3355</span>,3355,3355,3355<span class="o">}</span>
lesni_pozemek_v_r      <span class="p">|</span> <span class="o">{</span><span class="m">2</span>.23,2.23,2.23,2.23<span class="o">}</span>
orna_puda_pp           <span class="p">|</span> <span class="o">{</span><span class="m">88</span>,88,89,89<span class="o">}</span>
orna_puda_pp_r         <span class="p">|</span> <span class="o">{</span><span class="m">13</span>.13,13.17,13.40,13.34<span class="o">}</span>
orna_puda_v            <span class="p">|</span> <span class="o">{</span><span class="m">3066230</span>,3066230,3066230,3066230<span class="o">}</span>
orna_puda_v_avg        <span class="p">|</span> <span class="o">{</span><span class="m">34844</span>,34844,34452,34452<span class="o">}</span>
orna_puda_v_r          <span class="p">|</span> <span class="o">{</span><span class="m">81</span>.48,81.48,81.48,81.48<span class="o">}</span>
ostatni_plocha_pp      <span class="p">|</span> <span class="o">{</span><span class="m">201</span>,199,199,201<span class="o">}</span>
ostatni_plocha_pp_r    <span class="p">|</span> <span class="o">{</span><span class="m">30</span>.00,29.79,29.97,30.13<span class="o">}</span>
ostatni_plocha_v       <span class="p">|</span> <span class="o">{</span><span class="m">283468</span>,283468,283468,284562<span class="o">}</span>
ostatni_plocha_v_avg   <span class="p">|</span> <span class="o">{</span><span class="m">1410</span>,1424,1424,1416<span class="o">}</span>
ostatni_plocha_v_r     <span class="p">|</span> <span class="o">{</span><span class="m">7</span>.53,7.53,7.53,7.56<span class="o">}</span>
ovocny_sad_pp          <span class="p">|</span> <span class="o">{</span><span class="m">0</span>,0,0,0<span class="o">}</span>
ovocny_sad_pp_r        <span class="p">|</span> <span class="o">{</span><span class="m">0</span>.00,0.00,0.00,0.00<span class="o">}</span>
ovocny_sad_v           <span class="p">|</span> <span class="o">{</span><span class="m">0</span>,0,0,0<span class="o">}</span>
ovocny_sad_v_avg       <span class="p">|</span> <span class="o">{</span><span class="m">0</span>,0,0,0<span class="o">}</span>
ovocny_sad_v_r         <span class="p">|</span> <span class="o">{</span><span class="m">0</span>.00,0.00,0.00,0.00<span class="o">}</span>
ttp_pp                 <span class="p">|</span> <span class="o">{</span><span class="m">44</span>,44,44,45<span class="o">}</span>
ttp_pp_r               <span class="p">|</span> <span class="o">{</span><span class="m">6</span>.57,6.59,6.63,6.75<span class="o">}</span>
ttp_v                  <span class="p">|</span> <span class="o">{</span><span class="m">49002</span>,49002,49002,47908<span class="o">}</span>
ttp_v_avg              <span class="p">|</span> <span class="o">{</span><span class="m">1114</span>,1114,1114,1065<span class="o">}</span>
ttp_v_r                <span class="p">|</span> <span class="o">{</span><span class="m">1</span>.30,1.30,1.30,1.27<span class="o">}</span>
vinice_pp              <span class="p">|</span> <span class="o">{</span><span class="m">1</span>,1,1,1<span class="o">}</span>
vinice_pp_r            <span class="p">|</span> <span class="o">{</span><span class="m">0</span>.15,0.15,0.15,0.15<span class="o">}</span>
vinice_v               <span class="p">|</span> <span class="o">{</span><span class="m">106178</span>,106178,106178,106178<span class="o">}</span>
vinice_v_avg           <span class="p">|</span> <span class="o">{</span><span class="m">106178</span>,106178,106178,106178<span class="o">}</span>
vinice_v_r             <span class="p">|</span> <span class="o">{</span><span class="m">2</span>.82,2.82,2.82,2.82<span class="o">}</span>
vodni_plocha_pp        <span class="p">|</span> <span class="o">{</span><span class="m">23</span>,23,23,23<span class="o">}</span>
vodni_plocha_pp_r      <span class="p">|</span> <span class="o">{</span><span class="m">3</span>.43,3.44,3.46,3.45<span class="o">}</span>
vodni_plocha_v         <span class="p">|</span> <span class="o">{</span><span class="m">27877</span>,27877,27877,27877<span class="o">}</span>
vodni_plocha_v_avg     <span class="p">|</span> <span class="o">{</span><span class="m">1212</span>,1212,1212,1212<span class="o">}</span>
vodni_plocha_v_r       <span class="p">|</span> <span class="o">{</span><span class="m">0</span>.74,0.74,0.74,0.74<span class="o">}</span>
zahrada_pp             <span class="p">|</span> <span class="o">{</span><span class="m">115</span>,115,115,115<span class="o">}</span>
zahrada_pp_r           <span class="p">|</span> <span class="o">{</span><span class="m">17</span>.16,17.22,17.32,17.24<span class="o">}</span>
zahrada_v              <span class="p">|</span> <span class="o">{</span><span class="m">77381</span>,77381,77353,77353<span class="o">}</span>
zahrada_v_avg          <span class="p">|</span> <span class="o">{</span><span class="m">673</span>,673,673,673<span class="o">}</span>
zahrada_v_r            <span class="p">|</span> <span class="o">{</span><span class="m">2</span>.06,2.06,2.06,2.06<span class="o">}</span>
zastavena_plocha_pp    <span class="p">|</span> <span class="o">{</span><span class="m">173</span>,173,168,168<span class="o">}</span>
zastavena_plocha_pp_r  <span class="p">|</span> <span class="o">{</span><span class="m">25</span>.82,25.90,25.30,25.19<span class="o">}</span>
zastavena_plocha_v     <span class="p">|</span> <span class="o">{</span><span class="m">69240</span>,69240,69269,69269<span class="o">}</span>
zastavena_plocha_v_avg <span class="p">|</span> <span class="o">{</span><span class="m">400</span>,400,412,412<span class="o">}</span>
zastavena_plocha_v_r   <span class="p">|</span> <span class="o">{</span><span class="m">1</span>.84,1.84,1.84,1.84<span class="o">}</span>
</pre></div>


<p>Several stats were calculated for each land use category (vinice &rarr; vineyard, ovocny_sad &rarr; orchard,&nbsp;&#8230;):</p>
<ul>
<li><code>v_r</code> suffix stands for land use area&nbsp;ratio</li>
<li><code>pp_r</code> suffix stands for land use parcel count&nbsp;ratio</li>
<li><code>v_avg</code> stands for average parcel&nbsp;area</li>
</ul>
<p>All statistical columns are kept as PostgreSQL <code>ARRAY</code>s, ordered by dates (very handy for the future d3.js viz by the&nbsp;way).</p>
<blockquote>
<p>Note that since the <code>FULL OUTER JOIN</code> is needed in the next step, SQLite can&#8217;t be used. Pity&nbsp;though.</p>
</blockquote>
<p>The whole transformation bash script is the&nbsp;plain:</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

psql -qAt --no-psqlrc -f transform.sql <span class="p">|</span> psql -qAt --no-psqlrc
</pre></div>


<p>The <code>transform.sql</code> file is used to build the dynamic <span class="caps">SQL</span> query, which - once built - is piped to another <code>psql</code> command. I admit, pipes are super&nbsp;awesome.</p>
<div class="highlight"><pre><span></span><span class="k">WITH</span> <span class="n">tables</span> <span class="k">AS</span> <span class="p">(</span>
<span class="c1">-- FULL OUTER JOIN all the data_YYYYMMDD tables</span>
<span class="k">SELECT</span>
    <span class="k">table_name</span><span class="p">,</span>
    <span class="n">table_schema</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span> <span class="o">||</span> <span class="n">id</span> <span class="n">tbl</span><span class="p">,</span>
    <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">THEN</span> <span class="n">table_schema</span> <span class="o">||</span> <span class="s1">&#39;.&#39;</span> <span class="o">||</span> <span class="k">table_name</span> <span class="o">||</span> <span class="s1">&#39; d&#39;</span> <span class="o">||</span> <span class="n">id</span>
        <span class="k">ELSE</span> <span class="s1">&#39;FULL OUTER JOIN &#39;</span> <span class="o">||</span> <span class="n">table_schema</span> <span class="o">||</span> <span class="s1">&#39;.&#39;</span> <span class="o">||</span> <span class="k">table_name</span> <span class="o">||</span> <span class="s1">&#39; d&#39;</span> <span class="o">||</span> <span class="n">id</span> <span class="o">||</span> <span class="s1">&#39; ON (d1.ku_kod = d&#39;</span> <span class="o">||</span> <span class="n">id</span> <span class="o">||</span> <span class="s1">&#39;.ku_kod)&#39;</span>
    <span class="k">END</span> <span class="n">tbl_join</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="k">table_name</span><span class="p">,</span>
        <span class="n">table_schema</span><span class="p">,</span>
        <span class="n">row_number</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="k">table_name</span><span class="p">)</span> <span class="n">id</span>
    <span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">tables</span>
    <span class="k">WHERE</span> <span class="k">table_name</span> <span class="k">LIKE</span> <span class="s1">&#39;data_%&#39;</span>
        <span class="k">AND</span> <span class="n">table_type</span> <span class="o">=</span> <span class="s1">&#39;BASE TABLE&#39;</span>
        <span class="k">AND</span> <span class="n">table_schema</span> <span class="o">=</span> <span class="s1">&#39;public&#39;</span>
<span class="p">)</span> <span class="n">a</span>
<span class="p">)</span>
<span class="c1">-- create data table with the correct values order for each statistical column</span>
<span class="c1">-- note that the whole process would crash if d1.ku_kod would be NULL -&gt; @todo fix me</span>
<span class="k">SELECT</span> <span class="s1">&#39;DROP TABLE IF EXISTS data;</span>
<span class="s1">    CREATE TABLE data AS</span>
<span class="s1">    SELECT d1.ku_kod, d1.ku_nazev,&#39;</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span>
    <span class="n">array_to_string</span><span class="p">(</span><span class="n">array_agg</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="n">r</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
    <span class="s1">&#39;ARRAY[&#39;</span> <span class="o">||</span> <span class="n">array_to_string</span><span class="p">(</span><span class="n">array_agg</span><span class="p">(</span><span class="n">tables</span><span class="p">.</span><span class="n">tbl</span> <span class="o">||</span> <span class="s1">&#39;.&#39;</span> <span class="o">||</span> <span class="n">columns</span><span class="p">.</span><span class="k">column_name</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">tables</span><span class="p">.</span><span class="k">table_name</span><span class="p">),</span> <span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;]&#39;</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">columns</span><span class="p">.</span><span class="k">column_name</span> <span class="n">r</span>
    <span class="k">FROM</span> <span class="n">tables</span>
    <span class="k">JOIN</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">table_schema</span><span class="p">,</span>
        <span class="k">table_name</span><span class="p">,</span>
        <span class="k">column_name</span>
    <span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">columns</span>
    <span class="k">WHERE</span> <span class="k">column_name</span> <span class="k">NOT</span> <span class="k">LIKE</span> <span class="s1">&#39;ku_%&#39;</span>
    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">ordinal_position</span>
    <span class="p">)</span> <span class="n">columns</span>
    <span class="k">ON</span> <span class="p">(</span><span class="n">tables</span><span class="p">.</span><span class="k">table_name</span> <span class="o">=</span> <span class="n">columns</span><span class="p">.</span><span class="k">table_name</span> <span class="k">AND</span> <span class="n">columns</span><span class="p">.</span><span class="n">table_schema</span> <span class="o">=</span> <span class="n">tables</span><span class="p">.</span><span class="n">table_schema</span><span class="p">)</span>
    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">columns</span><span class="p">.</span><span class="k">column_name</span>
<span class="p">)</span> <span class="n">a</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="s1">&#39;FROM&#39;</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="n">tbl_join</span> <span class="k">FROM</span> <span class="n">tables</span><span class="p">;</span>
</pre></div>


<p><code>psql -qAt --no-psqlrc -f transform.sql</code> builds the actual query from the query above, <code>| psql -qAt --no-psqlrc</code> sends it to the database again. This part was really fun to&nbsp;implement!</p>
<p>I&#8217;m still considering to store diff values instead of absolute values in those <code>ARRAY</code>s - that would save some serious&nbsp;bandwidth!</p>
<h2>Load</h2>
<p>See <a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-load-part-iii/">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">III</span>)</a>.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-extraction-part-i" rel="bookmark" title="Permalink to Plotting the Czech Cadastre Land Use with d3: Data Extraction (part I)">Plotting the Czech Cadastre Land Use with d3: Data Extraction (part&nbsp;I)</a></h1>
            <small>Written on Nov 13, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/javascript.html">javascript</a>,         <a href="https://www.zimmi.cz/posts/tag/d3.html">d3</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/svg.html">svg</a>        | <a href="https://www.zimmi.cz/posts/category/data.html">data</a>
        </small>
        <section>
            <p>This post is the first part of the upcoming series summarizing the process of visualizing landuse data with bash, PostgreSQL and d3.js. Read other&nbsp;parts:</p>
<ol>
<li>you&#8217;re reading it&nbsp;now</li>
<li><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-transformation-part-ii">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">II</span>)</a></li>
<li><a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-load-part-iii/">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">III</span>)</a></li>
</ol>
<p><a href="http://cuzk.cz/en">Czech Office for Surveying, Mapping and Cadastre</a> has recently published lot of data via <a href="http://atom.cuzk.cz">Atom feed</a>. There&#8217;s pretty small and a bit boring dataset included, featuring quarterly updated landuse-related values for all 13,091 cadastral&nbsp;areas:</p>
<ul>
<li>absolute number of land lots within given category (arable land, forests,&nbsp;etc.)</li>
<li>absolute area of land lots within given&nbsp;category</li>
</ul>
<p>Data are published as <span class="caps">CSV</span> files linked from the Atom feed. Sadly, they come windows-1250 encoded, using Windows line endings, with trailing semicolons and header rows using&nbsp;diacritics.</p>
<h2><span class="caps">ETL</span>&nbsp;process</h2>
<p>Before the d3 viz can be crafted, it&#8217;s necessary&nbsp;to:</p>
<ol>
<li>extract <span class="caps">CSV</span> data from the URLs provided via the Atom&nbsp;feed</li>
<li>transform those data into a relational database, do some&nbsp;math</li>
<li>load data into a d3.js&nbsp;viz</li>
<li>profit (as&nbsp;usual)</li>
</ol>
<h3>Extract</h3>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1"># extract.sh -f YYYYMMDD</span>

<span class="k">while</span> <span class="o">[[</span> <span class="nv">$#</span> -gt <span class="m">1</span> <span class="o">]]</span>
<span class="k">do</span>
<span class="nv">key</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

<span class="k">case</span> <span class="nv">$key</span> in
    -f<span class="p">|</span>--file<span class="o">)</span>
    <span class="nv">FILE</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$2</span><span class="s2">&quot;</span>
    <span class="nb">shift</span> <span class="c1"># past argument</span>
    <span class="p">;;</span>
    *<span class="o">)</span>
        <span class="c1"># unknown option</span>
    <span class="p">;;</span>
<span class="k">esac</span>
<span class="nb">shift</span> <span class="c1"># past argument or value</span>
<span class="k">done</span>

<span class="nv">URL</span><span class="o">=</span>http://services.cuzk.cz/sestavy/UHDP/UHDP-
<span class="nv">CSVFILE</span><span class="o">=</span><span class="nv">$FILE</span>.csv
<span class="nv">CSVUTF8FILE</span><span class="o">=</span><span class="si">${</span><span class="nv">CSVFILE</span><span class="p">%.*</span><span class="si">}</span>.utf.csv
<span class="nv">URL</span><span class="o">+=</span><span class="nv">$CSVFILE</span>

<span class="nb">echo</span> <span class="s2">&quot;downloading </span><span class="nv">$URL</span><span class="s2">&quot;</span>
wget -q <span class="nv">$URL</span> -O <span class="nv">$CSVFILE</span>

<span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> !<span class="o">=</span> <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    rm -f <span class="nv">$CSVFILE</span>
    <span class="nb">echo</span> <span class="s2">&quot;download failed&quot;</span>
    <span class="nb">exit</span>
<span class="k">fi</span>

<span class="nb">echo</span> <span class="s2">&quot;converting to utf-8&quot;</span>
iconv -f WINDOWS-1250 -t UTF-8 <span class="nv">$CSVFILE</span> -o <span class="nv">$CSVUTF8FILE</span> <span class="o">&amp;&amp;</span> <span class="se">\</span>
<span class="nb">echo</span> <span class="s2">&quot;modifying </span><span class="si">${</span><span class="nv">FILE</span><span class="si">}</span><span class="s2">&quot;</span>
sed -i <span class="s1">&#39;s/^M$//&#39;</span> <span class="nv">$CSVUTF8FILE</span> <span class="o">&amp;&amp;</span> <span class="se">\</span>
sed -i <span class="s1">&#39;s/\r$//&#39;</span> <span class="nv">$CSVUTF8FILE</span> <span class="o">&amp;&amp;</span> <span class="se">\</span>
sed -i <span class="s1">&#39;s/;*$//g&#39;</span> <span class="nv">$CSVUTF8FILE</span> <span class="o">&amp;&amp;</span> <span class="se">\</span>
sed -i <span class="s1">&#39;1d&#39;</span> <span class="nv">$CSVUTF8FILE</span>

<span class="nb">echo</span> <span class="s2">&quot;importing to database&quot;</span>
sed -e <span class="s2">&quot;s/\${DATE}/</span><span class="nv">$FILE</span><span class="s2">/g&quot;</span> extract.sql <span class="p">|</span> psql -qAt --no-psqlrc

rm <span class="nv">$CSVFILE</span> <span class="nv">$CSVUTF8FILE</span>
</pre></div>


<p>This script downloads <span class="caps">CSV</span> file, deals with all the pitfalls mentioned above and, when done, <code>copy</code> command within <code>extract.sql</code> loads the data into a <code>data_YYYYMMDD</code> table. Putting all the files into the one table would have saved me a lot of transformation <span class="caps">SQL</span>, yet it didn&#8217;t feel quite right&nbsp;though.</p>
<h2>Transform</h2>
<p>See <a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-transformation-part-ii">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">II</span>)</a>.</p>
<h2>Load</h2>
<p>See <a href="https://www.zimmi.cz/posts/2016/plotting-czech-cadastre-land-use-with-d3-data-load-part-iii/">Plotting the Czech Cadastre Land Use with d3: Data Transformation (part <span class="caps">III</span>)</a>.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/postgis-custom-function-to-create-wind-rose/" rel="bookmark" title="Permalink to PostGIS Custom Function to Create Wind Rose">PostGIS Custom Function to Create Wind&nbsp;Rose</a></h1>
            <small>Written on Sep 1, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>I&#8217;ve come across the <a href="http://gis.stackexchange.com/questions/208797/draw-wind-rose-with-qgis-from-postgis/">beautiful <span class="caps">GIS</span> StackExchange question</a> recently, asking how to draw a <a href="https://en.wikipedia.org/wiki/Wind_rose">wind rose</a> within&nbsp;PostGIS.</p>
<div class="text-center">
<img src="http://i.stack.imgur.com/0xAMU.png">
</div>

<p>It&#8217;s pretty easy to accomplish this with a custom <span class="caps">PLPGSQL</span> procedure below, that takes line geometry, number of sections and radius of the inner circle as&nbsp;parameters.</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">ST_WindRose</span><span class="p">(</span>
    <span class="n">line</span> <span class="n">geometry</span><span class="p">,</span>
    <span class="n">directions</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">radius</span> <span class="nb">numeric</span>
<span class="p">)</span>
<span class="k">RETURNS</span> <span class="k">TABLE</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">integer</span><span class="p">,</span>
    <span class="n">geom</span> <span class="n">geometry</span><span class="p">(</span><span class="n">LINESTRING</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">AS</span> <span class="err">$</span><span class="n">ST_WindRose$</span>
<span class="k">BEGIN</span>
    <span class="k">IF</span> <span class="n">directions</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="k">THEN</span>
        <span class="n">RAISE</span> <span class="k">EXCEPTION</span> <span class="s1">&#39;Odd number of directions found, please provide even number of directions instead.&#39;</span><span class="p">;</span>
    <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>

<span class="k">IF</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="n">ST_Length</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">THEN</span>
    <span class="n">RAISE</span> <span class="k">EXCEPTION</span> <span class="s1">&#39;Inner circle radius is bigger than the wind rose diameter, please make it smaller.&#39;</span><span class="p">;</span>
<span class="k">END</span> <span class="k">IF</span><span class="p">;</span>

<span class="k">RETURN</span> <span class="n">QUERY</span>
<span class="k">WITH</span> <span class="n">rose</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">ST_Rotate</span><span class="p">(</span><span class="n">_line</span><span class="p">,</span> <span class="n">radians</span><span class="p">(</span><span class="mi">360</span><span class="p">)</span> <span class="o">/</span> <span class="n">directions</span> <span class="o">*</span> <span class="n">dirs</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ST_Centroid</span><span class="p">(</span><span class="n">_line</span><span class="p">))</span> <span class="n">_line</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">line</span> <span class="n">_line</span>
    <span class="p">)</span> <span class="n">a</span>
    <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">generate_series</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">directions</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="n">id</span>
    <span class="p">)</span> <span class="n">dirs</span>
<span class="p">)</span>
<span class="k">SELECT</span>
    <span class="n">row_number</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">()::</span><span class="nb">integer</span> <span class="n">id</span><span class="p">,</span>
    <span class="n">_line</span> <span class="n">geom</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">_line</span> <span class="k">FROM</span> <span class="n">rose</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="n">ST_ExteriorRing</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">ST_Centroid</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span> <span class="c1">-- inner circle</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="n">ST_ExteriorRing</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">ST_Centroid</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">ST_Length</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span> <span class="c1">-- outer circle</span>
<span class="p">)</span> <span class="n">a</span><span class="p">;</span>
<span class="k">END</span>
<span class="err">$</span><span class="n">ST_WindRose$</span>
<span class="k">LANGUAGE</span> <span class="n">PLPGSQL</span><span class="p">;</span>
</pre></div>


<p>Wind rose created with this function might look like the one&nbsp;below.</p>
<div class="text-center">
<img src="http://i.stack.imgur.com/4OD0J.png">
</div>

<p>Run it as follows. The <code>line</code> parameter should be a simple straight line made of just two&nbsp;vertices.</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ST_WindRose</span><span class="p">(</span><span class="n">ST_MakeLine</span><span class="p">(</span><span class="n">ST_MakePoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">ST_MakePoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">01</span><span class="p">);</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/postgis-custom-function-to-create-polygon-from-centroid/" rel="bookmark" title="Permalink to PostGIS Custom Function to Create Polygon from Centroid">PostGIS Custom Function to Create Polygon from&nbsp;Centroid</a></h1>
            <small>Written on Aug 28, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Needed to create a polygon from a point defining its size in both axes, here&#8217;s a little syntax sugar to make life&nbsp;easier.</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">ST_PolygonFromCentroid</span><span class="p">(</span><span class="n">centroid</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">xsize</span> <span class="nb">numeric</span><span class="p">,</span> <span class="n">ysize</span> <span class="nb">numeric</span><span class="p">)</span>
<span class="k">RETURNS</span> <span class="n">geometry</span>
<span class="k">AS</span> <span class="err">$</span><span class="n">ST_PolygonFromCentroid$</span>
<span class="k">SELECT</span> <span class="n">ST_MakeEnvelope</span><span class="p">(</span>
    <span class="n">ST_X</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">3</span><span class="p">)),</span>
    <span class="n">ST_Y</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">3</span><span class="p">)),</span>
    <span class="n">ST_X</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">)),</span>
    <span class="n">ST_Y</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">))</span>
<span class="p">);</span>
<span class="err">$</span><span class="n">ST_PolygonFromCentroid$</span>
<span class="k">LANGUAGE</span> <span class="k">SQL</span><span class="p">;</span>
</pre></div>


<p>Run it&nbsp;as:</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">ST_PolygonFromCentroid</span><span class="p">(</span><span class="n">ST_SetSRID</span><span class="p">(</span><span class="n">ST_MakePoint</span><span class="p">(</span><span class="mi">13</span><span class="p">.</span><span class="mi">912</span><span class="p">,</span><span class="mi">50</span><span class="p">.</span><span class="mi">633</span><span class="p">),</span><span class="mi">4326</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/finding-polygons-lying-across-other-polygons-with-postgis/" rel="bookmark" title="Permalink to Finding Polygons Lying across Other Polygons with PostGIS">Finding Polygons Lying across Other Polygons with&nbsp;PostGIS</a></h1>
            <small>Written on Aug 5, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Doing overlays (<code>ST_Intersection()</code>) in PostGIS based on spatial relationships (<code>ST_Intersects()</code>, <code>ST_Contains()</code>, &hellip;) is so easy it is not something you get particularly excited&nbsp;about.</p>
<p>Today I faced a bit more interesting task: <strong>given two polygon layers, get me all the polygons from layer A such that they lie across the polygons from layer B and&hellip; a picture worth a thousand words,&nbsp;right?</strong></p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/finding-polygons-lying-across-other-polygons-with-postgis/polygons.svg" /></div>

<p>I hope you got the idea, it is fairly&nbsp;simple:</p>
<ol>
<li>Intersect A (red, blue) with B&nbsp;(green)</li>
<li>Subtract the result of previous from layer&nbsp;A</li>
<li>Combine results from steps 1 and&nbsp;2</li>
<li>Keep polygon only if its id occurs more than twice (that means it went straight through the layer&nbsp;B)</li>
<li>Profit!</li>
</ol>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">WITH</span> <span class="n">overlays</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* nothing fancy here */</span>
    <span class="k">SELECT</span>
        <span class="n">A</span><span class="p">.</span><span class="n">ogc_fid</span> <span class="n">a_id</span><span class="p">,</span>
        <span class="n">B</span><span class="p">.</span><span class="n">ogc_fid</span> <span class="n">b_id</span><span class="p">,</span>
        <span class="n">ST_Intersection</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span><span class="p">,</span>
        <span class="n">ST_Area</span><span class="p">(</span><span class="n">ST_Intersection</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">area_shared</span>
    <span class="k">FROM</span> <span class="n">A</span>
    <span class="k">JOIN</span> <span class="n">B</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span>
<span class="p">),</span>
<span class="n">diffs</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* note this is a 1:1 relationship in ST_Difference */</span>
<span class="cm">/* a little hack is needed to prevent PostGIS from returning its usual difference mess */</span>
    <span class="k">SELECT</span>
        <span class="n">o</span><span class="p">.</span><span class="n">a_id</span><span class="p">,</span>
        <span class="n">o</span><span class="p">.</span><span class="n">b_id</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">ST_Difference</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">0001</span><span class="p">),</span> <span class="n">o</span><span class="p">.</span><span class="n">geom</span><span class="p">))).</span><span class="n">geom</span><span class="p">,</span> <span class="c1">-- ugly hack</span>
        <span class="n">o</span><span class="p">.</span><span class="n">area_shared</span>
    <span class="k">FROM</span> <span class="n">overlays</span> <span class="n">o</span>
    <span class="k">JOIN</span> <span class="n">A</span> <span class="k">ON</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">a_id</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="p">),</span>

<span class="n">merged</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* put those two result sets together */</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">overlays</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">diffs</span>
<span class="p">),</span>

<span class="n">merged_reduced</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* get only those A polygons that consist of three parts at least for each intersection with B polygon */</span>
  <span class="k">SELECT</span>
    <span class="n">m</span><span class="p">.</span><span class="o">*</span>
  <span class="k">FROM</span> <span class="n">merged</span> <span class="n">m</span>
  <span class="k">JOIN</span> <span class="p">(</span>
    <span class="k">SELECT</span>
      <span class="n">a_id</span><span class="p">,</span>
      <span class="n">b_id</span>
    <span class="k">FROM</span> <span class="n">merged</span>
    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">a_id</span><span class="p">,</span> <span class="n">b_id</span>
    <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
  <span class="p">)</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">a_id</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">a_id</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">b_id</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">b_id</span><span class="p">)</span>
<span class="p">)</span>
<span class="cm">/* do as you wish with the result */</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">merged_reduced</span><span class="p">;</span>
</pre></div>


<p>In my case, centerlines of layer B were also included and their length inside each intersection was used to divide the area of the smallest part with. It was fun,&nbsp;actually.</p>
        </section>
        </div>
    </div>

<div class="pagination row">
    <div class="large-6 columns">
    </div>
    <div class="large-6 columns">
            <a href="https://www.zimmi.cz/posts/tag/postgresql2.html" class="button card card-1">Next page &raquo;</a>
    </div>
    <!-- <p class="paginator">
            <a href="https://www.zimmi.cz/posts/tag/postgresql2.html" class="button card card-1">Next page &raquo;</a>
    </p> -->
</div>            </div>
        </div>
        <div class="row">
            <div class="large-12 columns footer">
                <footer>
                    <address>
                    Written by <a href="http://www.zimmi.cz">Michal Zimmermann</a>.
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    </address><!-- /#about -->
                </footer><!-- /#contentinfo -->
            </div>
        </div>
<!-- Piwik -->
<script type="text/javascript">
  var _paq = _paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['enableHeartBeatTimer']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//piwik-zimmi.rhcloud.com/analytics/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Piwik Code -->
<script src="https://www.zimmi.cz/posts/theme/js/packed.js?8bee1467"></script>
<script>
$(document).foundation();
</script>
</body>
</html>