<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
        <title>Michal Zimmermann | tag: postgis</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link href="https://www.zimmi.cz/posts/atom.xml" type="application/atom+xml" rel="alternate" title="Michal Zimmermann Full Atom Feed" />
        <link href="https://www.zimmi.cz/posts/feed.xml" type="application/rss+xml" rel="alternate" title="Michal Zimmermann Full RSS Feed" />
        <link rel="stylesheet" href="https://www.zimmi.cz/posts/theme/css/style.min.css?d5d1e141">
</head>

<body id="index" class="home">
    <nav class="top-bar card-1" data-topbar role="navigation">
        <ul class="title-area">
            <li class="name">
                <h1><a href="/posts">Home</a></h1>
            </li>
     <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
            <li class="toggle-topbar menu-icon"><a href="#"><span></span></a></li>
        </ul>
        <section class="top-bar-section">
    <!-- Right Nav Section -->
            <ul class="right">
                <li><a href="https://www.zimmi.cz/posts/categories">Categories</a></li>
                <li><a href="https://www.zimmi.cz/posts/tags">Tags</a></li>
                <li><a href="https://www.zimmi.cz/posts/feed.xml">RSS feed</a></li>
            </ul>
        </section>
    </nav>
        <div class="row">
          <div class="large-12 columns header">
            <h1><a href="/posts">Michal Zimmermann</a> <small>Pieces of knowledge from the world of GIS.</small></h1>
          </div>
        </div>
        <div class="row">
            <div class="large-12 columns">
<h2 class="text-center">Articles tagged with postgis tag</h2>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2017/routing-with-pgrouting-catchment-area-calculation/" rel="bookmark" title="Permalink to Routing with pgRouting: Catchment AreaÂ Calculation">Routing with pgRouting: Catchment Area&nbsp;Calculation</a></h1>
            <small>Written on Apr 14, 2017
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/pgrouting.html">pgrouting</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>For a long time I&#8217;ve wanted to play with <a href="http://pgrouting.org/">pgRouting</a> and that time has finally come. Among many other routing functions there is one that caught my eye, called <code>pgr_drivingdistance</code>. As the documentation says, it <em>returns the driving distance from a start node</em> using Dijkstra algorithm. The aforementioned distance doesn&#8217;t need to be defined in Euclidean space (the real distance between two points), it might be calculated in units of time, slopeness etc. How to get it&nbsp;going?</p>
<h2>Data</h2>
<p><span class="caps">OSM</span> will do as it always does. There is a tool called <code>osm2pgrouting</code> to help you load the data, the pure <span class="caps">GDAL</span> seems to be a better way to me though. Importing the downloaded data is&nbsp;trivial.</p>
<div class="highlight"><pre><span></span>ogr2ogr -f <span class="s2">&quot;PostgreSQL&quot;</span> PG:<span class="s2">&quot;dbname=pgrouting active_schema=cze&quot;</span> <span class="se">\</span>
    -s_srs EPSG:4326 <span class="se">\</span>
    -t_srs EPSG:5514 <span class="se">\</span>
    roads.shp <span class="se">\</span>
    -nln roads <span class="se">\</span>
    -lco <span class="nv">GEOMETRY_NAME</span><span class="o">=</span>the_geom <span class="se">\</span>
    -lco <span class="nv">FID</span><span class="o">=</span>id <span class="se">\</span>
    -gt <span class="m">65000</span> <span class="se">\</span>
    -nlt PROMOTE_TO_MULTI <span class="se">\</span>
    -clipsrc <span class="m">16</span>.538 <span class="m">49</span>.147 <span class="m">16</span>.699 <span class="m">49</span>.240
</pre></div>


<p>To route the network, it has to be properly noded. Although pgRouting comes with built-in <code>pgr_nodenetwork</code>, it didn&#8217;t seem to work very well. To node the network, use PostGIS <code>ST_Node</code>. <strong>Note this doesn&#8217;t consider bridges and&nbsp;tunnels.</strong></p>
<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">AS</span>
<span class="k">SELECT</span>
    <span class="p">(</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span> <span class="n">the_geom</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">ST_Node</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">ST_Union</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)</span> <span class="n">geom</span>
        <span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads</span>
    <span class="p">)</span> <span class="n">a</span>
<span class="p">)</span> <span class="n">b</span><span class="p">;</span>
</pre></div>


<p>After noding the network, all the information about speed limits and oneways is lost. If needed, it can be brought back with&nbsp;following:</p>
<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="k">ON</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">USING</span> <span class="n">gist</span><span class="p">(</span><span class="n">the_geom</span><span class="p">);</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">maxspeed</span> <span class="nb">integer</span><span class="p">;</span>

<span class="k">UPDATE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span>
<span class="k">SET</span> <span class="n">maxspeed</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">maxspeed</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="k">ON</span> <span class="p">(</span><span class="n">rn</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">rn</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
        <span class="n">r</span><span class="p">.</span><span class="n">maxspeed</span>
    <span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="n">rn</span>
    <span class="k">JOIN</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads</span> <span class="n">r</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">rn</span><span class="p">.</span><span class="n">the_geom</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">the_geom</span><span class="p">))</span>
    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">rn</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ST_Length</span><span class="p">(</span><span class="n">ST_Intersection</span><span class="p">(</span><span class="n">rn</span><span class="p">.</span><span class="n">the_geom</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">the_geom</span><span class="p">))</span> <span class="k">DESC</span>
<span class="p">)</span> <span class="n">a</span>
<span class="k">WHERE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</pre></div>


<p>With everything set, the topology can be&nbsp;built.</p>
<div class="highlight"><pre><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="k">source</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">target</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">pgr_createTopology</span><span class="p">(</span><span class="s1">&#39;cze.roads_noded&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>


<p>This function creates the <code>cze.roads_noded_vertices_pgr</code> that contains all the extracted nodes from the&nbsp;network.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/routing-with-pgrouting-catchment-area-calculation/nodes.png" width="70%" /></div>

<p>As already mentioned, measures other than length can be used as a distance, I chose the time to get to a given node on&nbsp;foot.</p>
<div class="highlight"><pre><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">cost_minutes</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span>
<span class="k">SET</span> <span class="n">cost_minutes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ST_Length</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)</span> <span class="o">/</span> <span class="mi">83</span><span class="p">.</span><span class="mi">0</span><span class="p">)::</span><span class="nb">integer</span><span class="p">;</span> <span class="c1">-- it takes average person one minute to walk 83 meters</span>

<span class="k">UPDATE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span>
<span class="k">SET</span> <span class="n">cost_minutes</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">WHERE</span> <span class="n">cost_minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<h2>Routing</h2>
<p>Now the interesting part. All the routing functions are built on what&#8217;s called <a href="http://docs.pgrouting.org/2.4/en/pgRouting-concepts.html#inner-queries"><em>inner queries</em></a> that are expected to return a certain data structure with no geometry included. As I want to see the results in <span class="caps">QGIS</span> immediately, I had to use a simple anonymous <span class="caps">PL</span>/pgSQL block that writes polygonal catchment areas to a table (consider it a proof of concept, not the final&nbsp;solution).</p>
<div class="highlight"><pre><span></span><span class="k">DROP</span> <span class="k">TABLE</span> <span class="k">IF</span> <span class="k">EXISTS</span> <span class="n">cze</span><span class="p">.</span><span class="n">temp</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">temp</span> <span class="k">AS</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded_vertices_pgr</span> <span class="n">ver</span>
<span class="k">JOIN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="o">*</span>
    <span class="k">FROM</span> <span class="n">pgr_drivingDistance</span><span class="p">(</span>
        <span class="s1">&#39;SELECT id, source, target, cost_minutes as cost, cost_minutes as reverse_cost FROM cze.roads_noded&#39;</span><span class="p">,</span>
        <span class="mi">6686</span><span class="p">,</span>
        <span class="mi">10</span><span class="p">,</span>
        <span class="k">true</span>
    <span class="p">)</span>
<span class="p">)</span><span class="n">dist</span> <span class="k">ON</span> <span class="n">ver</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">dist</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>

<span class="k">DO</span> <span class="err">$$</span>
<span class="k">DECLARE</span>
    <span class="k">c</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">BEGIN</span>
    <span class="k">DROP</span> <span class="k">TABLE</span> <span class="k">IF</span> <span class="k">EXISTS</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tmp</span> <span class="p">(</span>
        <span class="n">agg_cost</span> <span class="nb">integer</span><span class="p">,</span>
        <span class="n">geom</span> <span class="n">geometry</span><span class="p">(</span><span class="n">MULTIPOLYGON</span><span class="p">,</span> <span class="mi">5514</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">-- order by the biggest area so the polygons are not hidden beneath the bigger ones</span>
    <span class="k">FOR</span> <span class="k">c</span> <span class="k">IN</span> <span class="k">SELECT</span> <span class="n">agg_cost</span> <span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">temp</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">agg_cost</span> <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="mi">1</span> <span class="k">DESC</span> <span class="n">LOOP</span>
        <span class="n">RAISE</span> <span class="n">INFO</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="k">c</span><span class="p">;</span>
        <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">tmp</span> <span class="p">(</span><span class="n">agg_cost</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span>
        <span class="k">SELECT</span>
            <span class="k">c</span><span class="p">,</span>
            <span class="n">ST_Multi</span><span class="p">(</span><span class="n">ST_SetSRID</span><span class="p">(</span><span class="n">pgr_pointsAsPolygon</span><span class="p">(</span>
                <span class="s1">&#39;SELECT</span>
<span class="s1">                        temp.id::integer,</span>
<span class="s1">                        ST_X(temp.the_geom)::float AS x,</span>
<span class="s1">                        ST_Y(temp.the_geom)::float AS y</span>
<span class="s1">                FROM cze.temp</span>
<span class="s1">                WHERE agg_cost = &#39;</span> <span class="o">||</span> <span class="k">c</span>
            <span class="p">),</span> <span class="mi">5514</span><span class="p">));</span>
    <span class="k">END</span> <span class="n">LOOP</span><span class="p">;</span>
<span class="k">END</span><span class="err">$$</span><span class="p">;</span>
</pre></div>


<p>Using <code>pgr_pointsAsPolygon</code> renders resulting nodes accessible in 10-minute walk in polygons, but weird looking ones. Not bad, could be better&nbsp;though.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/routing-with-pgrouting-catchment-area-calculation/area1.png" width="70%" /></div>

<p>How about seeing only nodes instead of&nbsp;polygons?</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">agg_cost</span><span class="p">,</span>
    <span class="n">ST_PointN</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">agg_cost</span><span class="p">,</span>
        <span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span><span class="p">,</span>
        <span class="n">generate_series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ST_NumPoints</span><span class="p">(</span><span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)))</span> <span class="n">i</span>
    <span class="k">FROM</span> <span class="n">tmp</span>
<span class="p">)</span> <span class="n">a</span><span class="p">;</span>
</pre></div>


<p>Looks good, could be better&nbsp;though.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/routing-with-pgrouting-catchment-area-calculation/nodes1.png" width="70%" /></div>

<p>How about creating concave hulls from the extracted&nbsp;nodes?</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">agg_cost</span><span class="p">,</span>
    <span class="n">ST_ConcaveHull</span><span class="p">(</span><span class="n">ST_Union</span><span class="p">(</span><span class="n">geom</span><span class="p">))</span> <span class="n">geom</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">agg_cost</span><span class="p">,</span>
        <span class="n">ST_PointN</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="n">geom</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">agg_cost</span><span class="p">,</span><span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="ss">&quot;text-center&quot;</span><span class="o">&gt;&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="ss">&quot;{filename}/assets/routing-with-pgrouting-catchment-area-calculation/nodes1.png&quot;</span> <span class="n">width</span><span class="o">=</span><span class="ss">&quot;70%&quot;</span> <span class="o">/&gt;&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
            <span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span><span class="p">,</span>
            <span class="n">generate_series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ST_NumPoints</span><span class="p">(</span><span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)))</span> <span class="n">i</span>
        <span class="k">FROM</span> <span class="n">tmp</span>
    <span class="p">)</span> <span class="n">a</span>
<span class="p">)</span> <span class="n">b</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">agg_cost</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">agg_cost</span> <span class="k">DESC</span><span class="p">;</span>
</pre></div>


<p>This one looks the best I&nbsp;guess.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/routing-with-pgrouting-catchment-area-calculation/area2.png" width="70%" /></div>

<h2>Remarks</h2>
<ul>
<li>The documentation doesn&#8217;t help&nbsp;much.</li>
<li>I&#8217;d expect existing functions to return different data structures to be easy-to-use,&nbsp;actually.</li>
<li><code>LATERAL</code> might be really handy with those inner queries, have to give it a shot in the&nbsp;future.</li>
<li>Pedestrians usually don&#8217;t follow the road&nbsp;network.</li>
<li>Bridges and tunnels might be an&nbsp;issue.</li>
</ul>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2017/subdivide-and-conquer-effective-spatial-indexes-in-postgis/" rel="bookmark" title="Permalink to Subdivide and Conquer: Effective Spatial Indexes inÂ PostGIS">Subdivide and Conquer: Effective Spatial Indexes in&nbsp;PostGIS</a></h1>
            <small>Written on Jan 10, 2017
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Spatial indexes are absolutely crucial part of any spatial database and - as I tend to say quite often - only a fool would try to query spatial data without building spatial indexes&nbsp;beforehand.</p>
<p>Spatial indexes are based on bounding box comparisons, which are generally very fast. Yet, there are situations when spatial indexes don&#8217;t help much (or they don&#8217;t help as much as they could, if you&nbsp;wish).</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/subdivide-and-conquer-effective-spatial-indexes-in-postgis/index.svg" /></div>

<p>Bounding box comparisons are effective with lots of small bounding boxes rather then few large ones. Why? See the picture above. The curved line (imagine it&#8217;s a pipeline for example) clearly demonstrates when the spatial index/bounding box comparison might fall short of what you&#8217;d&nbsp;expect.</p>
<p>Once the bounding box gets really big, it intersects so many other geometries&#8217; bounding boxes that the whole comparison starts to slow&nbsp;down.</p>
<p>Luckily, PostGIS 2.2 introduced a <a href="http://postgis.net/docs/ST_Subdivide.html">ST_Subdivide</a> function that can lend a helping hand in&nbsp;here.</p>
<p>Until today, we delivered the parcel geometries into our <a href="https://www.symap.cz">real estate acquisition process system</a> with the following query, that takes all the geometries from the <code>req_geom</code> table (pipelines, remember?) and intersects them with cadastral parcels. The second part of the query adds those parcels that haven&#8217;t been digitalized and were created manually by one of my&nbsp;workmates.</p>
<div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
<span class="k">SELECT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="n">par_id</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
    <span class="n">req_geom</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">JOIN</span>
    <span class="n">pargeo</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span>
 <span class="k">UNION</span>
 <span class="k">SELECT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">idpar</span><span class="p">::</span><span class="nb">numeric</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
     <span class="n">req_man</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">);</span>
</pre></div>


<p>It&#8217;s a perfectly standard query that intersects several request geometries with ~20M parcels, nothing really fancy. Except that it takes 25 minutes to finish. Why? Pipelines,&nbsp;remember?</p>
<p>Yet, the query below takes only 30 seconds to finish (that&#8217;s a huge time saver considering that the whole process used to take ~40 minutes)! Why? Because the <code>ST_Subdivide</code> effectively shrinks the <code>req_geom</code> geometries until they have 50 vertices each at most. Such small geometries are perfect input for the bounding box comparison. Remember to call <code>DISTINCT</code> when using <code>ST_Subdivide</code>, you&#8217;d probably get duplicate parcel ids&nbsp;otherwise.</p>
<p>I also replaced the <code>UNION</code> with the <a href="https://www.zimmi.cz/posts/2015/postgresql-in-vs-exists/"><code>WHERE NOT EXISTS</code></a> expression, as it&#8217;s reasonable to assume that numeric ids comparison will be&nbsp;faster.</p>
<div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="k">DISTINCT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="n">par_id</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
    <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">uid</span><span class="p">,</span>
            <span class="n">ST_Subdivide</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="n">geom</span>
        <span class="k">FROM</span>
            <span class="n">req_geom</span>
     <span class="p">)</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">JOIN</span>
     <span class="n">pargeo</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">geom</span><span class="p">));</span>

 <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
 <span class="k">SELECT</span>
     <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
     <span class="n">a</span><span class="p">.</span><span class="n">idpar</span><span class="p">::</span><span class="nb">numeric</span>
 <span class="k">FROM</span>
     <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
     <span class="n">req_man</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">WHERE</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="p">(</span>
     <span class="k">SELECT</span> <span class="mi">1</span>
     <span class="k">FROM</span> <span class="n">pozadovane_parcely</span> <span class="n">pp</span>
     <span class="k">WHERE</span> <span class="n">pp</span><span class="p">.</span><span class="n">par_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">idpar</span>
  <span class="p">);</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/postgis-custom-function-to-create-wind-rose/" rel="bookmark" title="Permalink to PostGIS Custom Function to Create WindÂ Rose">PostGIS Custom Function to Create Wind&nbsp;Rose</a></h1>
            <small>Written on Sep 1, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>I&#8217;ve come across the <a href="http://gis.stackexchange.com/questions/208797/draw-wind-rose-with-qgis-from-postgis/">beautiful <span class="caps">GIS</span> StackExchange question</a> recently, asking how to draw a <a href="https://en.wikipedia.org/wiki/Wind_rose">wind rose</a> within&nbsp;PostGIS.</p>
<div class="text-center">
<img src="http://i.stack.imgur.com/0xAMU.png">
</div>

<p>It&#8217;s pretty easy to accomplish this with a custom <span class="caps">PLPGSQL</span> procedure below, that takes line geometry, number of sections and radius of the inner circle as&nbsp;parameters.</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">ST_WindRose</span><span class="p">(</span>
    <span class="n">line</span> <span class="n">geometry</span><span class="p">,</span>
    <span class="n">directions</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">radius</span> <span class="nb">numeric</span>
<span class="p">)</span>
<span class="k">RETURNS</span> <span class="k">TABLE</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">integer</span><span class="p">,</span>
    <span class="n">geom</span> <span class="n">geometry</span><span class="p">(</span><span class="n">LINESTRING</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">AS</span> <span class="err">$</span><span class="n">ST_WindRose$</span>
<span class="k">BEGIN</span>
    <span class="k">IF</span> <span class="n">directions</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="k">THEN</span>
        <span class="n">RAISE</span> <span class="k">EXCEPTION</span> <span class="s1">&#39;Odd number of directions found, please provide even number of directions instead.&#39;</span><span class="p">;</span>
    <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>

<span class="k">IF</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="n">ST_Length</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">THEN</span>
    <span class="n">RAISE</span> <span class="k">EXCEPTION</span> <span class="s1">&#39;Inner circle radius is bigger than the wind rose diameter, please make it smaller.&#39;</span><span class="p">;</span>
<span class="k">END</span> <span class="k">IF</span><span class="p">;</span>

<span class="k">RETURN</span> <span class="n">QUERY</span>
<span class="k">WITH</span> <span class="n">rose</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">ST_Rotate</span><span class="p">(</span><span class="n">_line</span><span class="p">,</span> <span class="n">radians</span><span class="p">(</span><span class="mi">360</span><span class="p">)</span> <span class="o">/</span> <span class="n">directions</span> <span class="o">*</span> <span class="n">dirs</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ST_Centroid</span><span class="p">(</span><span class="n">_line</span><span class="p">))</span> <span class="n">_line</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">line</span> <span class="n">_line</span>
    <span class="p">)</span> <span class="n">a</span>
    <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">generate_series</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">directions</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="n">id</span>
    <span class="p">)</span> <span class="n">dirs</span>
<span class="p">)</span>
<span class="k">SELECT</span>
    <span class="n">row_number</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">()::</span><span class="nb">integer</span> <span class="n">id</span><span class="p">,</span>
    <span class="n">_line</span> <span class="n">geom</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">_line</span> <span class="k">FROM</span> <span class="n">rose</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="n">ST_ExteriorRing</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">ST_Centroid</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span> <span class="c1">-- inner circle</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="n">ST_ExteriorRing</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">ST_Centroid</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">ST_Length</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span> <span class="c1">-- outer circle</span>
<span class="p">)</span> <span class="n">a</span><span class="p">;</span>
<span class="k">END</span>
<span class="err">$</span><span class="n">ST_WindRose$</span>
<span class="k">LANGUAGE</span> <span class="n">PLPGSQL</span><span class="p">;</span>
</pre></div>


<p>Wind rose created with this function might look like the one&nbsp;below.</p>
<div class="text-center">
<img src="http://i.stack.imgur.com/4OD0J.png">
</div>

<p>Run it as follows. The <code>line</code> parameter should be a simple straight line made of just two&nbsp;vertices.</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ST_WindRose</span><span class="p">(</span><span class="n">ST_MakeLine</span><span class="p">(</span><span class="n">ST_MakePoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">ST_MakePoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">01</span><span class="p">);</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/postgis-custom-function-to-create-polygon-from-centroid/" rel="bookmark" title="Permalink to PostGIS Custom Function to Create Polygon fromÂ Centroid">PostGIS Custom Function to Create Polygon from&nbsp;Centroid</a></h1>
            <small>Written on Aug 28, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Needed to create a polygon from a point defining its size in both axes, here&#8217;s a little syntax sugar to make life&nbsp;easier.</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="n">ST_PolygonFromCentroid</span><span class="p">(</span><span class="n">centroid</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">xsize</span> <span class="nb">numeric</span><span class="p">,</span> <span class="n">ysize</span> <span class="nb">numeric</span><span class="p">)</span>
<span class="k">RETURNS</span> <span class="n">geometry</span>
<span class="k">AS</span> <span class="err">$</span><span class="n">ST_PolygonFromCentroid$</span>
<span class="k">SELECT</span> <span class="n">ST_MakeEnvelope</span><span class="p">(</span>
    <span class="n">ST_X</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">3</span><span class="p">)),</span>
    <span class="n">ST_Y</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="err">$</span><span class="mi">3</span><span class="p">)),</span>
    <span class="n">ST_X</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">)),</span>
    <span class="n">ST_Y</span><span class="p">(</span><span class="n">ST_Translate</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">))</span>
<span class="p">);</span>
<span class="err">$</span><span class="n">ST_PolygonFromCentroid$</span>
<span class="k">LANGUAGE</span> <span class="k">SQL</span><span class="p">;</span>
</pre></div>


<p>Run it&nbsp;as:</p>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">ST_PolygonFromCentroid</span><span class="p">(</span><span class="n">ST_SetSRID</span><span class="p">(</span><span class="n">ST_MakePoint</span><span class="p">(</span><span class="mi">13</span><span class="p">.</span><span class="mi">912</span><span class="p">,</span><span class="mi">50</span><span class="p">.</span><span class="mi">633</span><span class="p">),</span><span class="mi">4326</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/finding-polygons-lying-across-other-polygons-with-postgis/" rel="bookmark" title="Permalink to Finding Polygons Lying across Other Polygons withÂ PostGIS">Finding Polygons Lying across Other Polygons with&nbsp;PostGIS</a></h1>
            <small>Written on Aug 5, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Doing overlays (<code>ST_Intersection()</code>) in PostGIS based on spatial relationships (<code>ST_Intersects()</code>, <code>ST_Contains()</code>, &hellip;) is so easy it is not something you get particularly excited&nbsp;about.</p>
<p>Today I faced a bit more interesting task: <strong>given two polygon layers, get me all the polygons from layer A such that they lie across the polygons from layer B and&hellip; a picture worth a thousand words,&nbsp;right?</strong></p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/finding-polygons-lying-across-other-polygons-with-postgis/polygons.svg" /></div>

<p>I hope you got the idea, it is fairly&nbsp;simple:</p>
<ol>
<li>Intersect A (red, blue) with B&nbsp;(green)</li>
<li>Subtract the result of previous from layer&nbsp;A</li>
<li>Combine results from steps 1 and&nbsp;2</li>
<li>Keep polygon only if its id occurs more than twice (that means it went straight through the layer&nbsp;B)</li>
<li>Profit!</li>
</ol>
<!-- codeblock -->

<div class="highlight"><pre><span></span><span class="k">WITH</span> <span class="n">overlays</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* nothing fancy here */</span>
    <span class="k">SELECT</span>
        <span class="n">A</span><span class="p">.</span><span class="n">ogc_fid</span> <span class="n">a_id</span><span class="p">,</span>
        <span class="n">B</span><span class="p">.</span><span class="n">ogc_fid</span> <span class="n">b_id</span><span class="p">,</span>
        <span class="n">ST_Intersection</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span><span class="p">,</span>
        <span class="n">ST_Area</span><span class="p">(</span><span class="n">ST_Intersection</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">area_shared</span>
    <span class="k">FROM</span> <span class="n">A</span>
    <span class="k">JOIN</span> <span class="n">B</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span>
<span class="p">),</span>
<span class="n">diffs</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* note this is a 1:1 relationship in ST_Difference */</span>
<span class="cm">/* a little hack is needed to prevent PostGIS from returning its usual difference mess */</span>
    <span class="k">SELECT</span>
        <span class="n">o</span><span class="p">.</span><span class="n">a_id</span><span class="p">,</span>
        <span class="n">o</span><span class="p">.</span><span class="n">b_id</span><span class="p">,</span>
        <span class="p">(</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">ST_Difference</span><span class="p">(</span><span class="n">ST_Buffer</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">0001</span><span class="p">),</span> <span class="n">o</span><span class="p">.</span><span class="n">geom</span><span class="p">))).</span><span class="n">geom</span><span class="p">,</span> <span class="c1">-- ugly hack</span>
        <span class="n">o</span><span class="p">.</span><span class="n">area_shared</span>
    <span class="k">FROM</span> <span class="n">overlays</span> <span class="n">o</span>
    <span class="k">JOIN</span> <span class="n">A</span> <span class="k">ON</span> <span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">a_id</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="p">),</span>

<span class="n">merged</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* put those two result sets together */</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">overlays</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">diffs</span>
<span class="p">),</span>

<span class="n">merged_reduced</span> <span class="k">AS</span> <span class="p">(</span>
<span class="cm">/* get only those A polygons that consist of three parts at least for each intersection with B polygon */</span>
  <span class="k">SELECT</span>
    <span class="n">m</span><span class="p">.</span><span class="o">*</span>
  <span class="k">FROM</span> <span class="n">merged</span> <span class="n">m</span>
  <span class="k">JOIN</span> <span class="p">(</span>
    <span class="k">SELECT</span>
      <span class="n">a_id</span><span class="p">,</span>
      <span class="n">b_id</span>
    <span class="k">FROM</span> <span class="n">merged</span>
    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">a_id</span><span class="p">,</span> <span class="n">b_id</span>
    <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
  <span class="p">)</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">a_id</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">a_id</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">b_id</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">b_id</span><span class="p">)</span>
<span class="p">)</span>
<span class="cm">/* do as you wish with the result */</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">merged_reduced</span><span class="p">;</span>
</pre></div>


<p>In my case, centerlines of layer B were also included and their length inside each intersection was used to divide the area of the smallest part with. It was fun,&nbsp;actually.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2016/dead-simple-random-points-in-polygons-with-postgis/" rel="bookmark" title="Permalink to Dead Simple Random Points in Polygons withÂ PostGIS">Dead Simple Random Points in Polygons with&nbsp;PostGIS</a></h1>
            <small>Written on Aug 3, 2016
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>        | <a href="https://www.zimmi.cz/posts/category/sql.html">SQL</a>
        </small>
        <section>
            <p>Since PostgreSQL 9.3 there has been a handy little keyword called <code>LATERAL</code>, which - combined with <code>JOIN</code> - might rock your <span class="caps">GIS</span> world in a second. To keep it simple, a <code>LATERAL JOIN</code> enables a subquery in the <code>FROM</code> part of a query to reference columns from preceding expressions in the <code>FROM</code> list. What the&nbsp;heck?</p>
<p>Imagine that not so unusual request to <strong>generate random points in polygons</strong> (something I needed to do today). Do it automatically without your favorite piece of desktop <span class="caps">GIS</span>&nbsp;software.</p>
<p>It is pretty easy using <code>LATERAL JOIN</code>:</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">VALUES</span><span class="p">(</span>
        <span class="mi">1</span><span class="p">,</span>
        <span class="n">ST_SetSRID</span><span class="p">(</span>
            <span class="n">ST_GeomFromText</span><span class="p">(</span>
                <span class="s1">&#39;POLYGON((0 0, -1 0, -1 -1, 0 -1, 0 0))&#39;</span>
            <span class="p">),</span>
        <span class="mi">4326</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">UNION</span> <span class="k">ALL</span>
    <span class="k">VALUES</span><span class="p">(</span>
        <span class="mi">2</span><span class="p">,</span>
        <span class="n">ST_SetSRID</span><span class="p">(</span>
            <span class="n">ST_GeomFromText</span><span class="p">(</span>
                <span class="s1">&#39;POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))&#39;</span>
            <span class="p">),</span>
        <span class="mi">4326</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span> <span class="n">a</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span>
<span class="k">CROSS</span> <span class="k">JOIN</span> <span class="k">LATERAL</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">ST_SetSRID</span><span class="p">(</span><span class="n">ST_MakePoint</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">4326</span><span class="p">)</span> <span class="n">geom</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">ST_XMax</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="o">-</span> <span class="n">ST_XMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span> <span class="o">+</span> <span class="n">ST_XMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">ST_YMax</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="o">-</span> <span class="n">ST_YMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span> <span class="o">+</span> <span class="n">ST_YMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">y</span>
        <span class="k">FROM</span> <span class="n">generate_series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
    <span class="p">)</span> <span class="n">tmp</span>
<span class="p">)</span> <span class="n">b</span><span class="p">;</span>
</pre></div>


<p>What actually happened over there? If you want to put points inside polygons, you need&#8230; polygons. We will do just fine with two of them created inside this&nbsp;query:</p>
<div class="highlight"><pre><span></span><span class="k">VALUES</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="n">ST_SetSRID</span><span class="p">(</span>
        <span class="n">ST_GeomFromText</span><span class="p">(</span>
            <span class="s1">&#39;POLYGON((0 0, -1 0, -1 -1, 0 -1, 0 0))&#39;</span>
        <span class="p">),</span>
    <span class="mi">4326</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">VALUES</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">ST_SetSRID</span><span class="p">(</span>
        <span class="n">ST_GeomFromText</span><span class="p">(</span>
            <span class="s1">&#39;POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))&#39;</span>
        <span class="p">),</span>
    <span class="mi">4326</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>


<p>All the magic happens inside the <code>LATERAL JOIN</code> part of the&nbsp;query:</p>
<div class="highlight"><pre><span></span><span class="k">CROSS</span> <span class="k">JOIN</span> <span class="k">LATERAL</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">ST_SetSRID</span><span class="p">(</span><span class="n">ST_MakePoint</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">4326</span><span class="p">)</span> <span class="n">geom</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">ST_XMax</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="o">-</span> <span class="n">ST_XMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span> <span class="o">+</span> <span class="n">ST_XMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">ST_YMax</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="o">-</span> <span class="n">ST_YMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span> <span class="o">+</span> <span class="n">ST_YMin</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">)</span> <span class="n">y</span>
        <span class="k">FROM</span> <span class="n">generate_series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
    <span class="p">)</span> <span class="n">tmp</span>
<span class="p">)</span> <span class="n">b</span><span class="p">;</span>
</pre></div>


<p>The inner <code>SELECT</code> calculates random points based on the extent of the polygon. Note it directly calls <code>a.geom</code>, a value that comes from the previous <code>SELECT</code>! The <code>LATERAL JOIN</code> part is thus run for every row of the previous <code>SELECT</code> statement inside <code>FROM</code> part of the query. This means it will return 201 points for each of the two polygons (run the query inside <span class="caps">QGIS</span> to see the&nbsp;result).</p>
<p>Note all the points fall inside the polygons by accident, because they are <strong>square</strong>. Otherwise a <code>ST_Contains</code> or <code>ST_Within</code> should be used inside the outermost <code>WHERE</code> query to filter outliers. This part could use some&nbsp;tweaking.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2015/liftago-open-dataset-infographics/" rel="bookmark" title="Permalink to Liftago Open DatasetÂ Infographics">Liftago Open Dataset&nbsp;Infographics</a></h1>
            <small>Written on Dec 21, 2015
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/python.html">python</a>,         <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/svg.html">svg</a>,         <a href="https://www.zimmi.cz/posts/tag/visualization.html">visualization</a>        | <a href="https://www.zimmi.cz/posts/category/data.html">data</a>
        </small>
        <section>
            <p><a href="https://www.liftago.com/cs">Liftago</a> (the Czech analogy of Uber) has recently <a href="http://try.liftago.com/info-wants-to-be-free/">released a sample of its data</a> covering four weeks of driver/pasenger&nbsp;interactions.</p>
<p>Have a look at my infographics created with PostGIS, Inkscape, Python and&nbsp;pygal.</p>
<p class="text-center"><a href="https://www.zimmi.cz/posts/assets/liftago-open-dataset-infographics/liftago.pdf"><img title="Liftago infographics" src="https://www.zimmi.cz/posts/assets/liftago-open-dataset-infographics/liftago.png" class="img-responsive centered"></a></p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2015/postgis-case-study-vozejkmap-open-data-part-iii/" rel="bookmark" title="Permalink to PostGIS Case Study: Vozejkmap Open Data (Part III)">PostGIS Case Study: Vozejkmap Open Data (Part <span class="caps">III</span>)</a></h1>
            <small>Written on Nov 14, 2015
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/leaflet.html">leaflet</a>,         <a href="https://www.zimmi.cz/posts/tag/javascript.html">javascript</a>        | <a href="https://www.zimmi.cz/posts/category/web-maps.html">web maps</a>
        </small>
        <section>
            <p>After a while I got back to my <a href="https://www.zimmi.cz/posts/2014/postgis-case-study-vozejkmap-open-data-part-i/">PostGIS open data</a> <a href="https://www.zimmi.cz/posts/2015/postgis-case-study-vozejkmap-open-data-part-ii/">case study</a>. Last time I left it with clustering implemented, looking forward to incorporate <a href="http://turfjs.org">Turf.js</a> in the future. <em>And the future is now.</em> <a href="https://github.com/zimmicz/vozejkmap-to-postgis">The code is still available on&nbsp;GitHub.</a></p>
<h2>Subgroup&nbsp;clustering</h2>
<p>Vozejkmap data is categorized based on the place type (banks, parking lots, pubs, &hellip;). One of the core features of map showing such data should be the easy way to turn these categories on and&nbsp;off.</p>
<p>As far as I know, it&#8217;s not trivial to do this with the standard Leaflet library. Extending <code>L.control.layers</code> and implement its <code>addOverlay</code>, <code>removeOverlay</code> methods on your own might be the way to add needed behavior. Fortunately, there&#8217;s an easier option thanks to <a href="https://github.com/ghybs/Leaflet.FeatureGroup.SubGroup">Leaflet.FeatureGroup.SubGroup</a> that can handle such use case and is really straightforward. See the code&nbsp;below.</p>
<div class="highlight"><pre><span></span><span class="nx">cluster</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">markerClusterGroup</span><span class="p">({</span>
    <span class="nx">chunkedLoading</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">chunkInterval</span><span class="o">:</span> <span class="mi">500</span>
<span class="p">});</span>

<span class="nx">cluster</span><span class="p">.</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>

<span class="p">...</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">category</span> <span class="k">in</span> <span class="nx">categories</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// just use L.featureGroup.subGroup instead of L.layerGroup or L.featureGroup</span>
    <span class="nx">overlays</span><span class="p">[</span><span class="nx">my</span><span class="p">.</span><span class="nx">Style</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">category</span><span class="p">).</span><span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">featureGroup</span><span class="p">.</span><span class="nx">subGroup</span><span class="p">(</span><span class="nx">cluster</span><span class="p">,</span> <span class="nx">categories</span><span class="p">[</span><span class="nx">category</span><span class="p">]);</span>
<span class="p">}</span>

<span class="nx">mapkey</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">control</span><span class="p">.</span><span class="nx">layers</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">overlays</span><span class="p">).</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>
</pre></div>


<p>With this piece of code you get a map key with checkboxes for all the categories, yet they&#8217;re still kept in the single cluster on the map.&nbsp;Brilliant!</p>
<p><img src="https://www.zimmi.cz/posts/assets/postgis-case-study-vozejkmap-open-data-part-iii/map.png" title="vozejkmap.cz data map" class="img-responsive centered"></p>
<h2>Using Turf.js for&nbsp;analysis</h2>
<p>Turf is one of those libraries I get amazed easily with, spending a week trying to find a use case, finally putting it aside with <em>&#8220;I&#8217;ll get back to it later&#8221;</em>. I usually don&#8217;t. This time it&#8217;s&nbsp;different.</p>
<p>I use Turf to get the nearest neighbor for any marker on click. My first try ended up with the same marker being the result as it was a member of a feature collection passed to <code>turf.nearest()</code> method. After snooping around the docs I found <code>turf.remove()</code> method that can filter GeoJSON based on key-value&nbsp;pair.</p>
<p>Another handy function is <code>turf.distance()</code> that gives you distance between two points. The code below adds an information about the nearest point and its distance into the&nbsp;popup.</p>
<div class="highlight"><pre><span></span><span class="c1">// data is a geojson feature collection</span>
<span class="nx">json</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">geoJson</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">onEachFeature</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">feature</span><span class="p">,</span> <span class="nx">layer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">layer</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">nearest</span> <span class="o">=</span> <span class="nx">turf</span><span class="p">.</span><span class="nx">nearest</span><span class="p">(</span><span class="nx">layer</span><span class="p">.</span><span class="nx">toGeoJSON</span><span class="p">(),</span> <span class="nx">turf</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="nx">feature</span><span class="p">.</span><span class="nx">properties</span><span class="p">.</span><span class="nx">title</span><span class="p">)),</span>
                <span class="nx">distance</span> <span class="o">=</span> <span class="nx">turf</span><span class="p">.</span><span class="nx">distance</span><span class="p">(</span><span class="nx">layer</span><span class="p">.</span><span class="nx">toGeoJSON</span><span class="p">(),</span> <span class="nx">nearest</span><span class="p">,</span> <span class="s2">&quot;kilometers&quot;</span><span class="p">).</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                <span class="nx">popup</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">popup</span><span class="p">({</span><span class="nx">offset</span><span class="o">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">35</span><span class="p">]}).</span><span class="nx">setLatLng</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">latlng</span><span class="p">),</span>
                <span class="nx">content</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">Util</span><span class="p">.</span><span class="nx">template</span><span class="p">(</span>
                    <span class="s2">&quot;&lt;h1&gt;{title}&lt;/h1&gt;&lt;p&gt;{description}&lt;/p&gt; \</span>
<span class="s2">                    &lt;p&gt;NejbliÅ¾Å¡Ã­ bod: {nearest} je {distance} km daleko.&lt;/p&gt;&quot;</span><span class="p">,</span> <span class="p">{</span>
                    <span class="nx">title</span><span class="o">:</span> <span class="nx">feature</span><span class="p">.</span><span class="nx">properties</span><span class="p">.</span><span class="nx">title</span><span class="p">,</span>
                    <span class="nx">description</span><span class="o">:</span> <span class="nx">feature</span><span class="p">.</span><span class="nx">properties</span><span class="p">.</span><span class="nx">description</span><span class="p">,</span>
                    <span class="nx">nearest</span><span class="o">:</span> <span class="nx">nearest</span><span class="p">.</span><span class="nx">properties</span><span class="p">.</span><span class="nx">title</span><span class="p">,</span>
                    <span class="nx">distance</span><span class="o">:</span> <span class="nx">distance</span>
                <span class="p">});</span>

            <span class="nx">popup</span><span class="p">.</span><span class="nx">setContent</span><span class="p">(</span><span class="nx">content</span><span class="p">);</span>
            <span class="nx">popup</span><span class="p">.</span><span class="nx">openOn</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>

            <span class="p">...</span>
</pre></div>


<p>From what I&#8217;ve tried so far, Turf seems to be incredibly fast and easy to use. I&#8217;ll try to find the nearest point for any of the categories, that could take Turf some&nbsp;time.</p>
<h2>Update</h2>
<p>Turf is blazing fast! I&#8217;ve implemented nearest point for each of the categories and it gets done in a blink of an eye. Some screenshots below. Geolocation implemented as&nbsp;well.</p>
<p><img src="https://www.zimmi.cz/posts/assets/postgis-case-study-vozejkmap-open-data-part-iii/screen1.png" title="vozejkmap.cz data map" class="img-responsive centered"> You can locate the point&nbsp;easily.</p>

<p><img src="https://www.zimmi.cz/posts/assets/postgis-case-study-vozejkmap-open-data-part-iii/screen2.png" title="vozejkmap.cz data map" class="img-responsive centered"> You can hide the&nbsp;infobox.</p>

<p><img src="https://www.zimmi.cz/posts/assets/postgis-case-study-vozejkmap-open-data-part-iii/screen3.png" title="vozejkmap.cz data map" class="img-responsive centered">You can jump to any of the nearest&nbsp;places.</p>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2015/installing-postgis-22-with-sfcgal-on-ubuntu-based-os/" rel="bookmark" title="Permalink to Installing PostGIS 2.2 with SFCGAL on Ubuntu-based OS">Installing PostGIS 2.2 with <span class="caps">SFCGAL</span> on Ubuntu-based <span class="caps">OS</span></a></h1>
            <small>Written on Oct 29, 2015
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>,         <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/linux.html">linux</a>        | <a href="https://www.zimmi.cz/posts/category/development.html">development</a>
        </small>
        <section>
            <p>I&#8217;ve seen a bunch of questions on <span class="caps">GIS</span> StackExchange recently related to <a href="http://sfcgal.org/"><span class="caps">SFCGAL</span></a> extension for <a href="http://postgis.net">PostGIS 2.2</a>. Great news are it can be installed with one simple query <code>CREATE EXTENSION postgis_sfcgal</code>. Not so great news are you have to compile it from source for Ubuntu-based <span class="caps">OS</span> (14.04) as recent versions of required packages are not available in the&nbsp;repositories.</p>
<p>I tested my solution on elementary <span class="caps">OS</span> 0.3.1 based on Ubuntu 14.04. <strong>And it works!</strong> It installs PostgreSQL 9.4 from repositories together with <span class="caps">GDAL</span> and <span class="caps">GEOS</span> and some other libs PostGIS depends on. PostGIS itself, <span class="caps">CGAL</span>, Boost, <span class="caps">MPFR</span> and <span class="caps">GMP</span> are built from&nbsp;source.</p>
<p>Here comes the code (commented where&nbsp;needed).</p>
<div class="highlight"><pre><span></span>sudo -i
<span class="nb">echo</span> <span class="s2">&quot;deb http://apt.postgresql.org/pub/repos/apt/ trusty-pgdg main&quot;</span> <span class="p">|</span> tee -a /etc/apt/sources.list
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc <span class="p">|</span> sudo apt-key add -
apt-get update
apt-get install -y postgresql-9.4 <span class="se">\</span>
    postgresql-client-9.4 <span class="se">\</span>
    postgresql-contrib-9.4 <span class="se">\</span>
    libpq-dev <span class="se">\</span>
    postgresql-server-dev-9.4 <span class="se">\</span>
    build-essential <span class="se">\</span>
    libgeos-c1 <span class="se">\</span>
    libgdal-dev <span class="se">\</span>
    libproj-dev <span class="se">\</span>
    libjson0-dev <span class="se">\</span>
    libxml2-dev <span class="se">\</span>
    libxml2-utils <span class="se">\</span>
    xsltproc <span class="se">\</span>
    docbook-xsl <span class="se">\</span>
    docbook-mathml <span class="se">\</span>
    cmake <span class="se">\</span>
    gcc <span class="se">\</span>
    m4 <span class="se">\</span>
    icu-devtools

<span class="nb">exit</span> <span class="c1"># leave root otherwise postgis will choke</span>

<span class="nb">cd</span> /tmp
touch download.txt
cat <span class="s">&lt;&lt;EOT &gt;&gt; download.txt</span>
<span class="s">https://gmplib.org/download/gmp/gmp-6.0.0a.tar.bz2</span>
<span class="s">https://github.com/Oslandia/SFCGAL/archive/v1.2.0.tar.gz</span>
<span class="s">http://www.mpfr.org/mpfr-current/mpfr-3.1.3.tar.gz</span>
<span class="s">http://downloads.sourceforge.net/project/boost/boost/1.59.0/boost_1_59_0.tar.gz</span>
<span class="s">https://github.com/CGAL/cgal/archive/releases/CGAL-4.6.3.tar.gz</span>
<span class="s">http://download.osgeo.org/postgis/source/postgis-2.2.0.tar.gz</span>

<span class="s">EOT</span>

cat download.txt <span class="p">|</span> xargs -n <span class="m">1</span> -P <span class="m">8</span> wget <span class="c1"># make wget a little bit faster</span>

tar xjf gmp-6.0.0a.tar.bz2
tar xzf mpfr-3.1.3.tar.gz
tar xzf v1.2.0.tar.gz
tar xzf boost_1_59_0.tar.gz
tar xzf CGAL-4.6.3.tar.gz
tar xzf postgis-2.2.0.tar.gz

<span class="nv">CORES</span><span class="o">=</span><span class="k">$(</span>nproc<span class="k">)</span>

<span class="k">if</span> <span class="o">[[</span> <span class="nv">$CORES</span> &gt; <span class="m">1</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CORES</span><span class="o">=</span><span class="k">$(</span>expr <span class="nv">$CORES</span> - <span class="m">1</span><span class="k">)</span> <span class="c1"># be nice to your PC</span>
<span class="k">fi</span>

<span class="nb">cd</span> gmp-6.0.0
./configure <span class="o">&amp;&amp;</span> make -j <span class="nv">$CORES</span> <span class="o">&amp;&amp;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> mpfr-3.1.3
./configure <span class="o">&amp;&amp;</span> make -j <span class="nv">$CORES</span> <span class="o">&amp;&amp;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> boost_1_59_0
./bootstrap.sh --prefix<span class="o">=</span>/usr/local --with-libraries<span class="o">=</span>all <span class="o">&amp;&amp;</span> sudo ./b2 install <span class="c1"># there might be some warnings along the way, don&#39;t panic</span>
<span class="nb">echo</span> <span class="s2">&quot;/usr/local/lib&quot;</span> <span class="p">|</span> sudo tee /etc/ld.so.conf.d/boost.conf
sudo ldconfig

<span class="nb">cd</span> ..
<span class="nb">cd</span> cgal-releases-CGAL-4.6.3
cmake . <span class="o">&amp;&amp;</span> make -j <span class="nv">$CORES</span> <span class="o">&amp;&amp;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> SFCGAL-1.2.0/
cmake . <span class="o">&amp;&amp;</span> make -j <span class="nv">$CORES</span> <span class="o">&amp;&amp;</span> sudo make -j <span class="nv">$CORES</span> install

<span class="nb">cd</span> ..
<span class="nb">cd</span> postgis-2.2.0
./configure <span class="se">\</span>
    --with-geosconfig<span class="o">=</span>/usr/bin/geos-config <span class="se">\</span>
    --with-xml2config<span class="o">=</span>/usr/bin/xml2-config <span class="se">\</span>
    --with-projdir<span class="o">=</span>/usr/share/proj <span class="se">\</span>
    --with-libiconv<span class="o">=</span>/usr/bin <span class="se">\</span>
    --with-jsondir<span class="o">=</span>/usr/include/json <span class="se">\</span>
    --with-gdalconfig<span class="o">=</span>/usr/bin/gdal-config <span class="se">\</span>
    --with-raster <span class="se">\</span>
    --with-topology <span class="se">\</span>
    --with-sfcgal<span class="o">=</span>/usr/local/bin/sfcgal-config <span class="o">&amp;&amp;</span> <span class="se">\</span>
make <span class="o">&amp;&amp;</span> make cheatsheets <span class="o">&amp;&amp;</span> sudo make install <span class="c1"># deliberately one CPU only</span>

sudo -u postgres psql
sudo -u postgres createdb spatial_template
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;CREATE EXTENSION postgis;&quot;</span>
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;CREATE EXTENSION postgis_topology;&quot;</span>
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;CREATE EXTENSION postgis_sfcgal;&quot;</span>
sudo -u postgres psql -d spatial_template -c <span class="s2">&quot;SELECT postgis_full_version();&quot;</span>
</pre></div>
        </section>
        </div>
    </div>

    <div class="panel card card-1">
        <div class="post-name">
            <h1><a href="https://www.zimmi.cz/posts/2015/automated-map-creation-with-qgis-postgis-python-svg-and-imagemagick/" rel="bookmark" title="Permalink to Automated Map Creation With QGIS, PostGIS, Python, SVG andÂ ImageMagick">Automated Map Creation With <span class="caps">QGIS</span>, PostGIS, Python, <span class="caps">SVG</span> and&nbsp;ImageMagick</a></h1>
            <small>Written on Aug 9, 2015
        and marked as
        <a href="https://www.zimmi.cz/posts/tag/qgis.html">qgis</a>,         <a href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>,         <a href="https://www.zimmi.cz/posts/tag/python.html">python</a>,         <a href="https://www.zimmi.cz/posts/tag/svg.html">svg</a>,         <a href="https://www.zimmi.cz/posts/tag/linux.html">linux</a>        | <a href="https://www.zimmi.cz/posts/category/automation.html">automation</a>
        </small>
        <section>
            <p>As mentioned in <a href="https://www.zimmi.cz/posts/2015/qgis-tips-for-collaborative-mapping/"><span class="caps">QGIS</span> Tips For Collaborative Mapping</a> we&#8217;re in the middle of crop evaluation project at <a href="http://www.clevermaps.cz/">CleverMaps</a>.</p>
<p>With the <span class="caps">QGIS</span> workflow up and running, I&#8217;ve been focused on different <span class="caps">QGIS</span> related task: <strong>automatic map generation</strong> for land blocks that meet certain conditions. The logic behind identifying such land blocks is as&nbsp;follows:</p>
<ul>
<li>if the original area and the measured one differ more than 0.5 %&nbsp;or</li>
<li>number of declared crops differs from number of crops identified&nbsp;or</li>
<li>at least one parcel in the land block was given a certain error&nbsp;code</li>
</ul>
<p>Let&#8217;s assume that with several lines of <span class="caps">SQL</span> code we can store these mentioned above in a table called <code>land_blocks</code> with geometries being the result of calling <code>ST_Union()</code> over parcels for each land&nbsp;block.</p>
<h2>Map&nbsp;composition</h2>
<p>Every map should feature following&nbsp;layers:</p>
<ul>
<li>land blocks (remember the <code>land_blocks</code> table?) - labeled with <span class="caps">ID</span>, yellowish borders, no&nbsp;fill</li>
<li>land parcels - that&#8217;s my source layer - labeled with letters, blue borders, no&nbsp;fill</li>
<li>other&nbsp;layers</li>
<li><span class="caps">HR</span>, <span class="caps">VHR</span>, <span class="caps">NIR</span> imagery, orthophoto - served via <span class="caps">WMS</span></li>
</ul>
<p>Labels should be visible only for the featured land block (both for the land parcels and the land block itself. The whole map scales dynamically, showing small land blocks zoomed in and the large ones zoomed&nbsp;out.</p>
<p class='text-center'><a id="desired-map" title="Desired map" href="https://www.zimmi.cz/posts/assets/automated-map-creation-with-qgis-postgis-python-svg-and-imagemagick/map.jpg"><img title="Desired map" src="https://www.zimmi.cz/posts/assets/automated-map-creation-with-qgis-postgis-python-svg-and-imagemagick/map.jpg" width=70% class="img-responsive centered"></a></p>

<p>Every map features additional&nbsp;items:</p>
<ul>
<li>dynamic list of subsidies farmer asks for - showing both measured and declared&nbsp;area</li>
<li>dynamic list of land parcels with their areas and error&nbsp;codes</li>
<li>scalebar</li>
<li>map&nbsp;key</li>
<li>logos</li>
</ul>
<h2>Atlas&nbsp;creation</h2>
<p>Now with requirements defined, let&#8217;s create some maps. It&#8217;s incredibly easy to generate a series of maps with <span class="caps">QGIS</span> atlas&nbsp;options.</p>
<h3>Atlas generation&nbsp;settings</h3>
<p><strong>Coverage layer</strong> is presumably the only thing you really need - as the name suggests, it covers your area of interest. One map will be created for each feature in this layer, unless you decide to use some <strong>filtering</strong> - which I&nbsp;did.</p>
<p><strong>Output filenames</strong> can be tweaked to your needs, here&#8217;s what such a function might look like. If there is a slash in the land block <span class="caps">ID</span> (<span class="caps">XXXXXXX</span>/Y), the filename is set to <code>USER-ID_XXXXXXX-00Y_M_00</code>, <code>USER-ID_XXXXXXX-000_M_00</code> otherwise.</p>
<div class="highlight"><pre><span></span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">strpos</span><span class="p">(</span><span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">),</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">THEN</span>
        <span class="n">ji</span> <span class="o">||</span> <span class="s1">&#39;_&#39;</span> <span class="o">||</span>
        <span class="n">substr</span><span class="p">(</span>
            <span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">strpos</span><span class="p">(</span><span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">),</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="c1">-- slash position</span>
        <span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;-&#39;</span> <span class="o">||</span>
        <span class="n">lpad</span><span class="p">(</span>
            <span class="n">substr</span><span class="p">(</span>
                <span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">),</span>
                <span class="n">strpos</span><span class="p">(</span><span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">),</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
                <span class="k">length</span><span class="p">(</span><span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">))</span>
            <span class="p">),</span>
        <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;_M_00&#39;</span>
    <span class="k">ELSE</span>
        <span class="n">ji</span> <span class="o">||</span> <span class="s1">&#39;_&#39;</span> <span class="o">||</span> <span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;-000_M_00&#39;</span>
<span class="k">END</span>
</pre></div>


<h3>Map scale <span class="amp">&amp;</span> variable&nbsp;substitutions</h3>
<p>Different land blocks are of different sizes, thus needing different <strong>scales</strong> to fit in the map. Again, <span class="caps">QGIS</span> handles this <em>might-become-a-nightmare-pretty-easily</em> issue with a single click. You can define the scale&nbsp;as:</p>
<ul>
<li>margin around feature: percentage of the space displayed&nbsp;around</li>
<li>predefined scale (best fit): my choice, sometimes it doesn&#8217;t display the entire land block&nbsp;though</li>
<li>fixed scale: sets the scale the same for all the&nbsp;maps</li>
</ul>
<p>With these settings, I get a map similar to the one below. Notice two interesting&nbsp;things:</p>
<p class='text-center'><a title="QGIS map skeleton" href="https://www.zimmi.cz/posts/assets/automated-map-creation-with-qgis-postgis-python-svg-and-imagemagick/map_skeleton.png"><img title="QGIS map skeleton" src="https://www.zimmi.cz/posts/assets/automated-map-creation-with-qgis-postgis-python-svg-and-imagemagick/map_skeleton.png" width=70% class="img-responsive centered"></a></p>

<ul>
<li>Scale uses decimal places, which I find <em>a huge failure</em>. Has anyone ever seen a map with such scale? The worst is there is no easy way to hide these, or at least I didn&#8217;t find&nbsp;one.</li>
<li>You can see a bunch of <code>[something in the brackets]</code> notations. These will be substituted with actual values during the atlas generation. Showing land block <span class="caps">ID</span> with a preceeding label is as easy as <code>[%concat('PB: ', "kod_pb")%]</code> (mind the percentage&nbsp;sign).</li>
</ul>
<h3>Styling the map using atlas&nbsp;features</h3>
<p>Atlas features are a great help for <strong>map customization</strong>. As mentioned earlier, in my case, only one land block label per map should be visible. That can be achieved with a simple label dialog&nbsp;expression:</p>
<div class="highlight"><pre><span></span><span class="k">CASE</span>
    <span class="k">WHEN</span> <span class="err">$</span><span class="n">id</span> <span class="o">=</span> <span class="err">$</span><span class="n">atlasfeatureid</span>
    <span class="k">THEN</span> <span class="ss">&quot;kod_pb&quot;</span>
<span class="k">END</span>
</pre></div>


<p><span class="caps">QGIS</span> keeps reference to each coverage layer feature <span class="caps">ID</span> during atlas generation, so you can use it for comparison. The best part is you can use IDs with <strong>any layer</strong> you&nbsp;need:</p>
<div class="highlight"><pre><span></span><span class="k">CASE</span>
    <span class="k">WHEN</span> <span class="n">attribute</span><span class="p">(</span><span class="err">$</span><span class="n">atlasfeature</span><span class="p">,</span> <span class="s1">&#39;kod_pb&#39;</span><span class="p">)</span> <span class="o">=</span> <span class="ss">&quot;kod_pb&quot;</span>
    <span class="k">THEN</span> <span class="ss">&quot;kod_zp&quot;</span>
<span class="k">END</span>
</pre></div>


<p>With this simple expression, I get labels only for those land parcels that are part of the mapped land block. Even the <strong>layer style</strong> can be controlled with atlas feature. Land parcels inside the land block have blue borders, the rest is yellowish, remember? It&#8217;s a piece of cake with rule-based&nbsp;styling.</p>
<p class='text-center'><a title="Layer style based on atlas feature" href="https://www.zimmi.cz/posts/assets/automated-map-creation-with-qgis-postgis-python-svg-and-imagemagick/atlas_feature_style.png"><img title="Layer style based on atlas feature" src="https://www.zimmi.cz/posts/assets/automated-map-creation-with-qgis-postgis-python-svg-and-imagemagick/atlas_feature_style.png" width=70% class="img-responsive centered"></a></p>

<h3>Atlas&nbsp;generation</h3>
<p>When you&#8217;re set, atlas can be created with a single button. I used <span class="caps">SVG</span> as an output format to easily manipulate the map content afterwards. The resulting maps look like the one in <a href="#desired-map">the first picture</a> without the text in the red rectangle. A Python script appends this to each map&nbsp;afterwards.</p>
<p>Roughly speaking, generating 300 maps takes an hour or so, I guess that depends on the map complexity and hardware&nbsp;though.</p>
<h3>Adding textual&nbsp;content</h3>
<p><span class="caps">SVG</span> output is just plain old <span class="caps">XML</span> that you can edit by hand or by script. A simple Python script, part of map post-processing, loads <span class="caps">SVG</span> from the database and adds it to the left pane of each&nbsp;map.</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span>
      <span class="n">ji</span><span class="p">,</span>
      <span class="n">kod_pb</span><span class="p">,</span>
      <span class="n">concat</span><span class="p">(</span>
            <span class="s1">&#39;&lt;g fill=&quot;none&quot; stroke=&quot;#000000&quot; stroke-opacity=&quot;1&quot; stroke-width=&quot;1&quot;</span>
<span class="s1">                  stroke-linecap=&quot;square&quot; stroke-linejoin=&quot;bevel&quot; transform=&quot;matrix(1.18081,0,0,1.18081,270.0,550.0)&quot;</span>
<span class="s1">                  font-family=&quot;Droid Sans&quot; font-size=&quot;35&quot; font-style=&quot;normal&quot;&gt;&#39;</span><span class="p">,</span>
            <span class="n">kultura</span><span class="p">,</span> <span class="n">vymery</span><span class="p">,</span> <span class="n">vymery_hodnoty</span><span class="p">,</span>
            <span class="n">vcs_titul</span><span class="p">,</span> <span class="n">vcs_brk</span><span class="p">,</span> <span class="n">vcs_brs</span><span class="p">,</span> <span class="n">vcs_chmel</span><span class="p">,</span>
            <span class="n">vcs_zvv</span><span class="p">,</span> <span class="n">vcs_zv</span><span class="p">,</span> <span class="n">vcs_ovv</span><span class="p">,</span> <span class="n">vcs_ov</span><span class="p">,</span> <span class="n">vcs_cur</span><span class="p">,</span> <span class="n">vcs_bip</span><span class="p">,</span>
            <span class="n">lfa</span><span class="p">,</span> <span class="n">lfa_h1</span><span class="p">,</span> <span class="n">lfa_h2</span><span class="p">,</span> <span class="n">lfa_h3</span><span class="p">,</span>
            <span class="n">lfa_h4</span><span class="p">,</span> <span class="n">lfa_h5</span><span class="p">,</span> <span class="n">lfa_oa</span><span class="p">,</span> <span class="n">lfa_ob</span><span class="p">,</span> <span class="n">lfa_s</span><span class="p">,</span>
            <span class="n">natura</span><span class="p">,</span> <span class="n">aeo_eafrd_text</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_a1</span><span class="p">,</span>
            <span class="n">dv_aeo_eafrd_a2o</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_a2v</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_b1</span><span class="p">,</span>
            <span class="n">dv_aeo_eafrd_b2</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_b3</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_b4</span><span class="p">,</span>
            <span class="n">dv_aeo_eafrd_b5</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_b6</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_b7</span><span class="p">,</span>
            <span class="n">dv_aeo_eafrd_b8</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_b9</span><span class="p">,</span> <span class="n">dv_aeo_eafrd_c1</span><span class="p">,</span>
            <span class="n">dv_aeo_eafrd_c3</span><span class="p">,</span> <span class="n">aeko_text</span><span class="p">,</span> <span class="n">dv_aeko_a</span><span class="p">,</span> <span class="n">dv_aeko_b</span><span class="p">,</span> <span class="n">dv_aeko_c</span><span class="p">,</span>
            <span class="n">dv_aeko_d1</span><span class="p">,</span> <span class="n">dv_aeko_d2</span><span class="p">,</span> <span class="n">dv_aeko_d3</span><span class="p">,</span> <span class="n">dv_aeko_d4</span><span class="p">,</span> <span class="n">dv_aeko_d5</span><span class="p">,</span>
            <span class="n">dv_aeko_d6</span><span class="p">,</span> <span class="n">dv_aeko_d7</span><span class="p">,</span> <span class="n">dv_aeko_d8</span><span class="p">,</span> <span class="n">dv_aeko_d9</span><span class="p">,</span> <span class="n">dv_aeko_d10</span><span class="p">,</span>
            <span class="n">dv_aeko_e</span><span class="p">,</span> <span class="n">dv_aeko_f</span><span class="p">,</span> <span class="n">ez</span><span class="p">,</span> <span class="n">dzes_text</span><span class="p">,</span> <span class="n">rep</span><span class="p">,</span> <span class="n">obi</span><span class="p">,</span> <span class="n">seop</span><span class="p">,</span> <span class="n">meop</span><span class="p">,</span> <span class="n">pbz</span><span class="p">,</span> <span class="n">dzes7</span><span class="p">,</span>
            <span class="s1">&#39;&lt;/g&gt;&#39;</span>
      <span class="p">)</span> <span class="n">popis</span>
<span class="k">FROM</span> <span class="p">(...);</span>
</pre></div>


<p>Each column from the previous query is a result of <code>SELECT</code> similar to the one&nbsp;below.</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">concat</span><span class="p">(</span><span class="s1">&#39;&lt;text fill=&quot;#000000&quot; fill-opacity=&quot;1&quot; stroke=&quot;none&quot;&gt;BrK: &#39;</span><span class="p">,</span> <span class="n">dv_brk</span><span class="p">,</span> <span class="s1">&#39; ha / &#39;</span><span class="p">,</span> <span class="ss">&quot;MV_BRK&quot;</span><span class="p">,</span> <span class="s1">&#39; ha;&#39;</span><span class="p">,</span> <span class="n">kod_dpz</span><span class="p">,</span> <span class="s1">&#39;&lt;/text&gt;&#39;</span><span class="p">)</span> <span class="n">vcs_brk</span>
</pre></div>


<p>The <code>transform="matrix(1.18081,0,0,1.18081,270.0,550.0)</code> part puts the text on the right spot. Great finding about <span class="caps">SVG</span> is that it places each <code>&lt;text&gt;</code> element on the new line, so you don&#8217;t need to deal with calculating the position in your&nbsp;script.</p>
<p>Scale adjustment is done with a dirty lambda&nbsp;function.</p>
<div class="highlight"><pre><span></span><span class="n">content</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&gt;(\d{1,3}\.\d{3,5})&lt;/text&gt;&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span> <span class="p">:</span><span class="s2">&quot;&gt;    &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))))</span> <span class="o">+</span> <span class="s2">&quot;&lt;/text&gt;&quot;</span><span class="p">,</span> <span class="n">old_map</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>


<h3><span class="caps">SVG</span> to <span class="caps">JPEG</span>&nbsp;conversion</h3>
<p>We deliver maps as <span class="caps">JPEG</span> files with 150 <span class="caps">DPI</span> on A4 paper format. <a href="http://www.imagemagick.org/script/index.php">ImageMagick</a> converts the formats with a simple shell&nbsp;command:</p>
<div class="highlight"><pre><span></span>convert -density <span class="m">150</span> -resize 1753x1240 input.svg output.jpg
</pre></div>


<h2>Conclusion</h2>
<p>I created pretty efficient semi-automated workflow using several open source technologies that saves me a lot of work. Although <span class="caps">QGIS</span> has some minor pet peeves (scale with decimal places, not showing the entire feature, not substituting variables at times), it definitely makes boring map creation quite amusing. The more I work with big data / on big tasks, the more I find Linux a&nbsp;must-have.</p>
<p>The whole process was done with <span class="caps">QGIS</span> 2.10, PostGIS 2.1, PostgreSQL 9.3, Python 2.7, ImageMagick&nbsp;6.7.</p>
        </section>
        </div>
    </div>

<div class="pagination row">
    <div class="large-6 columns">
    </div>
    <div class="large-6 columns">
            <a href="https://www.zimmi.cz/posts/tag/postgis2.html" class="button card card-1">Next page &raquo;</a>
    </div>
    <!-- <p class="paginator">
            <a href="https://www.zimmi.cz/posts/tag/postgis2.html" class="button card card-1">Next page &raquo;</a>
    </p> -->
</div>            </div>
        </div>
        <div class="row">
            <div class="large-12 columns footer">
                <footer>
                    <address>
                    Written by <a href="http://www.zimmi.cz">Michal Zimmermann</a>.
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    </address><!-- /#about -->
                </footer><!-- /#contentinfo -->
            </div>
        </div>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-43432739-2']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script src="https://www.zimmi.cz/posts/theme/js/packed.js?8bee1467"></script>
<script>
$(document).foundation();
</script>
</body>
</html>