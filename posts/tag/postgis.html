<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
        <title>Michal Zimmermann | tag: postgis</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel="stylesheet">
        <link href="https://www.zimmi.cz/posts/atom.xml" type="application/atom+xml" rel="alternate" title="Michal Zimmermann Full Atom Feed" />
        <link href="https://www.zimmi.cz/posts/feed.xml" type="application/rss+xml" rel="alternate" title="Michal Zimmermann Full RSS Feed" />
        <link rel="stylesheet" href="https://www.zimmi.cz/posts/theme/css/style.min.css?0c7c5d39">
</head>
<body>
    <nav role="navigation">
        <ul>
            <li><a href="https://www.zimmi.cz/posts/categories">Categories</a></li>
            <li><a href="https://www.zimmi.cz/posts/tags">Tags</a></li>
            <li><a href="https://www.zimmi.cz/posts/feed.xml">Subscribe to RSS feed</a></li>
            <li>
                <form class="search" name="x" action="//duckduckgo.com/" target="_blank">
                    <input type="hidden" value="zimmi.cz/posts" name="sites"></input>
                    <input class="search-input" type="search" placeholder="Search" name="q"></input>
                    <input class="button" type="submit" value="Go"></input>
                </form>
            </li>
        </ul>
    </nav>
    <header>
        <h1><a href="/posts">Michal Zimmermann<small>Pieces of knowledge from the world of GIS.</small></a></h1>
    </header>
    <main>
<h2 class="text-center">Articles tagged with postgis tag</h2>

<article>
    <h1><a href="https://www.zimmi.cz/posts/2018/centos-postgis-upgrade-hell-yet-again" rel="bookmark" title="Permalink to CentOS PostGIS Upgrade Hell… Yet Again">CentOS PostGIS Upgrade Hell&#8230; Yet&nbsp;Again</a></h1>
    <aside><span>Dec 19, 2018</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p><a href="https://www.zimmi.cz/posts/2017/upgrading-postgresql-95-to-postgresql-96-with-postgis/">PostGIS upgrades used to be a nightmare</a>. Broken dependencies, version mismatches, you name it. Upgrading PostgreSQL 10 with PostGIS 2.4 to PostgreSQL 11 on CentOS has been my mission impossible for two days. And it doesn&#8217;t seem to come to an&nbsp;end.</p>
<h2>What?&nbsp;Why?</h2>
<p>We&#8217;re running fairly large spatially enabled PostgreSQL 10 database cluster. To keep up with pretty fast development, I was hoping to <code>pg_upgrade</code> it to PostgreSQL&nbsp;11.</p>
<h2>Tried and&nbsp;failed</h2>
<p>I&#8217;ve been trying different upgrade strategies with PostgreSQL 11 already running to no avail. Here comes the&nbsp;list.</p>
<h3>Install PostGIS 2.4 to PostgreSQL 11 and&nbsp;pg_upgrade</h3>
<div class="highlight"><pre><span></span>yum install postgis24_11
systemctl stop postgresql-11

su postgres
/usr/pgsql-11/bin/pg_upgrade <span class="se">\</span>
  --check <span class="se">\</span>
  -b /usr/pgsql-10/bin/ -B /usr/pgsql-11/bin/ <span class="se">\</span>
  -d /var/lib/pgsql/10/data -D /var/lib/pgsql/11/data <span class="se">\</span>
  --link <span class="se">\</span>
  -U root <span class="se">\</span>
  -o <span class="s1">&#39; -c config_file=/var/lib/pgsql/10/data/postgresql.conf&#39;</span> -O <span class="s1">&#39; -c config_file=/var/lib/pgsql/11/data/postgresql.conf&#39;</span>
</pre></div>


<p>This results&nbsp;in:</p>
<blockquote>
<p>Your installation references loadable libraries that are missing from the
new installation.  You can add these libraries to the new installation,
or remove the functions using them from the old installation.  A list of
problem libraries is in the file:&nbsp;loadable_libraries.txt</p>
</blockquote>
<p><code>loadable_libraries.txt</code> says the&nbsp;following:</p>
<div class="highlight"><pre><span></span>could not load library <span class="s2">&quot;</span><span class="nv">$libdir</span><span class="s2">/postgis-2.4&quot;</span>: ERROR:  could not load library <span class="s2">&quot;/usr/pgsql-11/lib/postgis-2.4.so&quot;</span>: /usr/pgsql-11/lib/postgis-2.4.so: undefined symbol: geod_polygon_init
</pre></div>


<p>Duckduckgoing I found the related <a href="https://www.postgresql.org/message-id/15450-a3638dc978caa94d@postgresql.org">PostgreSQL mailing list thread</a>.</p>
<h3>Build and install PostGIS 2.4 from source to PostgreSQL 11 and&nbsp;pg_upgrade</h3>
<p>The bug report says there&#8217;s something wrong with <code>proj4</code> version, so I chose <code>proj49</code> and <code>geos37</code>.</p>
<div class="highlight"><pre><span></span>yum install proj49 proj49-devel
wget https://download.osgeo.org/postgis/source/postgis-2.4.6.tar.gz
tar -xzvf postgis-2.4.6.tar.gz
<span class="nb">cd</span> postgis-2.4.6

./configure <span class="se">\</span>
  --with-pgconfig<span class="o">=</span>/usr/pgsql-11/bin/pg_config <span class="se">\</span>
  --with-geosconfig<span class="o">=</span>/usr/geos37/bin/geos-config <span class="se">\</span>
  --with-projdir<span class="o">=</span>/usr/proj49/

make <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make install
</pre></div>


<p><code>CREATE EXTENSION postgis</code> fails with <code>could not load library "/usr/pgsql-11/lib/postgis-2.4.so": /usr/pgsql-11/lib/postgis-2.4.so: undefined symbol: geod_polygon_init</code>. Oh&nbsp;my.</p>
<h3>Install PostGIS 2.5 to PostgreSQL 10 and&nbsp;pg_upgrade</h3>
<p>Running out of ideas, I tried to install PostGIS 2.5 to our PostgreSQL 10 cluster and&nbsp;pg_upgrade.</p>
<div class="highlight"><pre><span></span>yum install postgis25_10
</pre></div>


<p>The resulting error appeared almost&nbsp;instantly:</p>
<div class="highlight"><pre><span></span>Transaction check error:
file /usr/pgsql-10/bin/shp2pgsql-gui from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/lib/liblwgeom.so from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/lib/postgis-2.4.so from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/address_standardizer.control from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/address_standardizer.sql from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/address_standardizer_data_us.control from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/address_standardizer_data_us.sql from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/postgis.control from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/postgis_sfcgal.control from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/postgis_tiger_geocoder.control from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
file /usr/pgsql-10/share/extension/postgis_topology.control from install of postgis25_10-2.5.1-1.rhel7.x86_64 conflicts with file from package postgis24_10-2.4.5-1.rhel7.x86_64
</pre></div>


<p>What&nbsp;the&hellip;</p>
<h3>Build and install PostGIS 2.5 from source to PostgreSQL 10 and&nbsp;pg_upgrade</h3>
<div class="highlight"><pre><span></span>wget https://download.osgeo.org/postgis/source/postgis-2.5.1.tar.gz
tar -xzvf postgis-2.5.1.tar.gz
<span class="nb">cd</span> postgis-2.5.1

./configure <span class="se">\</span>
  --with-pgconfig<span class="o">=</span>/usr/pgsql-10/bin/pg_config <span class="se">\</span>
  --with-geosconfig<span class="o">=</span>/usr/geos37/bin/geos-config

make <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make install
</pre></div>


<p><code>CREATE EXTENSION postgis</code> fails with <code>ERROR:  could not load library "/usr/pgsql-10/lib/postgis-2.5.so": /usr/pgsql-10/lib/postgis-2.5.so: undefined symbol: GEOSFrechetDistanceDensify</code>. Again?&nbsp;Really?</p>
<p><code>GEOSFrechetDistanceDensify</code> was added in <span class="caps">GEOS</span> 3.7 (linked in <code>./configure</code>), yet <code>ldd /usr/pgsql-10/lib/postgis-2.5.so</code> says:</p>
<div class="highlight"><pre><span></span>linux-vdso.so.1 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span>  <span class="o">(</span>0x00007ffd4c5fa000<span class="o">)</span>
libgeos_c.so.1 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/geos36/lib64/libgeos_c.so.1 <span class="o">(</span>0x00007f68ddf5a000<span class="o">)</span>
libproj.so.0 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libproj.so.0 <span class="o">(</span>0x00007f68ddd07000<span class="o">)</span>
libjson-c.so.2 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libjson-c.so.2 <span class="o">(</span>0x00007f68ddafc000<span class="o">)</span>
libxml2.so.2 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libxml2.so.2 <span class="o">(</span>0x00007f68dd792000<span class="o">)</span>
libm.so.6 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libm.so.6 <span class="o">(</span>0x00007f68dd48f000<span class="o">)</span>
libSFCGAL.so.1 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libSFCGAL.so.1 <span class="o">(</span>0x00007f68dc9c0000<span class="o">)</span>
libc.so.6 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libc.so.6 <span class="o">(</span>0x00007f68dc5f3000<span class="o">)</span>
libgeos-3.6.3.so <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/geos36/lib64/libgeos-3.6.3.so <span class="o">(</span>0x00007f68dc244000<span class="o">)</span>
libstdc++.so.6 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libstdc++.so.6 <span class="o">(</span>0x00007f68dbf3d000<span class="o">)</span>
libgcc_s.so.1 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libgcc_s.so.1 <span class="o">(</span>0x00007f68dbd27000<span class="o">)</span>
libdl.so.2 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libdl.so.2 <span class="o">(</span>0x00007f68dbb22000<span class="o">)</span>
libz.so.1 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libz.so.1 <span class="o">(</span>0x00007f68db90c000<span class="o">)</span>
liblzma.so.5 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/liblzma.so.5 <span class="o">(</span>0x00007f68db6e6000<span class="o">)</span>
/lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x000055960f119000<span class="o">)</span>
libCGAL.so.11 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libCGAL.so.11 <span class="o">(</span>0x00007f68db4bd000<span class="o">)</span>
libCGAL_Core.so.11 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libCGAL_Core.so.11 <span class="o">(</span>0x00007f68db284000<span class="o">)</span>
libmpfr.so.4 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libmpfr.so.4 <span class="o">(</span>0x00007f68db029000<span class="o">)</span>
libgmp.so.10 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libgmp.so.10 <span class="o">(</span>0x00007f68dadb0000<span class="o">)</span>
libboost_date_time-mt.so.1.53.0 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libboost_date_time-mt.so.1.53.0 <span class="o">(</span>0x00007f68dab9f000<span class="o">)</span>
libboost_thread-mt.so.1.53.0 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libboost_thread-mt.so.1.53.0 <span class="o">(</span>0x00007f68da988000<span class="o">)</span>
libboost_system-mt.so.1.53.0 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libboost_system-mt.so.1.53.0 <span class="o">(</span>0x00007f68da783000<span class="o">)</span>
libboost_serialization-mt.so.1.53.0 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/libboost_serialization-mt.so.1.53.0 <span class="o">(</span>0x00007f68da517000<span class="o">)</span>
libpthread.so.0 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /lib64/libpthread.so.0 <span class="o">(</span>0x00007f68da2fa000<span class="o">)</span>
librt.so.1 <span class="o">=</span><span class="p">&amp;</span>gt<span class="p">;</span> /usr/lib64/librt.so.1 <span class="o">(</span>0x00007f68da0f2000<span class="o">)</span>
</pre></div>


<p>I&#8217;m nearly desperate after spending two days trying to break through. I have ~ 300 <span class="caps">GB</span> of PostgreSQL data to migrate to the current version and there seems to be no possible way to do it in&nbsp;CentOS.</p>
<p>One more thing to note: using <code>yum install postgis25_11</code> and <code>CREATE EXTENSION postgis</code> in v11 database fails with the exact same error like the one above. I really enjoy working with PostgreSQL and PostGIS, yet there&#8217;s hardly something I fear more than trying to upgrade those two things&nbsp;together.</p>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2017/serving-mapbox-vector-tiles-with-postgis-nginx-and-python-backend/" rel="bookmark" title="Permalink to Serving Mapbox Vector Tiles with PostGIS, Nginx and Python Backend">Serving Mapbox Vector Tiles with PostGIS, Nginx and Python&nbsp;Backend</a></h1>
    <aside><span>Oct 23, 2017</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/python.html">python</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p><a href="https://www.zimmi.cz/posts/2017/postgis-as-a-mapbox-vector-tiles-generator/">Since version 2.4.0, PostGIS can serve <span class="caps">MVT</span></a> data directly. <span class="caps">MVT</span> returning queries put heavy workload on the database though. On top of that, each of the query has to be run again every time a client demands the data. This leaves us with plenty of room to optimize the&nbsp;process.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/serving-mapbox-vector-tiles-with-postgis-nginx-and-python-backend/election.gif"/></div>

<p>During the last week, while working on the Czech legislative election data visualization, I&#8217;ve struggled with the server becoming unresponsive far too often due to the issues mentioned&nbsp;above.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/serving-mapbox-vector-tiles-with-postgis-nginx-and-python-backend/schema.png"/></div>

<p>According to the schema, the first client to come to the&nbsp;server:</p>
<ul>
<li>goes through filesystem unstopped, because there are no cached files&nbsp;yet,</li>
<li>continues to the Flask backend and asks for a file at <code>{z}/{x}/{y}</code>,</li>
<li>Flask backend asks the database to return the <span class="caps">MVT</span> for the given&nbsp;tile,</li>
<li>Flask backend writes the response to the filesystem and sends it to the&nbsp;client.</li>
</ul>
<p>Other clients get tiles directly from the filesystem, leaving the database at&nbsp;ease.</p>
<h2>Nginx</h2>
<p>Nginx is fairly simple to set up, once you know what you&#8217;re doing. The <code>/volby-2017/municipality/</code> location serves static <span class="caps">MVT</span> from the given alias directory. If not found, the request is passed to <code>@postgis</code> location, that asks the Flask backend for the&nbsp;response.</p>
<div class="highlight"><pre><span></span>server election <span class="o">{</span>
    location /volby-2017/municipality <span class="o">{</span>
            <span class="nb">alias</span> /opt/volby-cz-2017/server/cache/<span class="p">;</span>
            try_files <span class="nv">$uri</span> @postgis<span class="p">;</span>
    <span class="o">}</span>

    location @postgis <span class="o">{</span>
            include uwsgi_params<span class="p">;</span>
            uwsgi_pass <span class="m">127</span>.0.0.1:5000<span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h2>Flask&nbsp;backend</h2>
<script src="https://gist.github.com/zimmicz/46485676e1cf3d6566f0aaa7f93f055b.js"></script>

<h2>Generating static <span class="caps">MVT</span> in&nbsp;advance</h2>
<p>If you&#8217;re going to serve static tiles that don&#8217;t change often, it might be a good idea to use PostGIS to create files in advance and serve them with&nbsp;Nginx.</p>
<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tiles</span> <span class="p">(</span>
    <span class="n">x</span> <span class="nb">integer</span><span class="p">,</span>
    <span class="n">y</span> <span class="nb">integer</span><span class="p">,</span>
    <span class="n">z</span> <span class="nb">integer</span><span class="p">,</span>
    <span class="n">west</span> <span class="nb">numeric</span><span class="p">,</span>
    <span class="n">south</span> <span class="nb">numeric</span><span class="p">,</span>
    <span class="n">east</span> <span class="nb">numeric</span><span class="p">,</span>
    <span class="n">north</span> <span class="nb">numeric</span><span class="p">,</span>
    <span class="n">geom</span> <span class="n">geometry</span><span class="p">(</span><span class="n">POLYGON</span><span class="p">,</span> <span class="mi">3857</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>


<p>Using <a href="https://github.com/mapbox/mercantile">mercantile</a>, you can create the <code>tiles</code> table holding the bounding boxes of the tiles you need. PostGIS them inserts the actual <span class="caps">MVT</span> into the <code>mvt</code> table.</p>
<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TEMPORARY</span> <span class="k">TABLE</span> <span class="n">tmp_tiles</span> <span class="k">AS</span>
    <span class="k">SELECT</span>
        <span class="n">muni</span><span class="p">.</span><span class="n">muni_id</span><span class="p">,</span>
        <span class="n">prc</span><span class="p">.</span><span class="k">data</span><span class="p">,</span>
        <span class="n">ST_AsMVTGeom</span><span class="p">(</span>
            <span class="n">muni</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span>
            <span class="n">TileBBox</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">3857</span><span class="p">),</span>
            <span class="mi">4096</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="k">false</span>
        <span class="p">)</span> <span class="n">geom</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">z</span>
    <span class="k">FROM</span> <span class="n">muni</span>
    <span class="k">JOIN</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">y</span><span class="p">,</span>
            <span class="n">z</span><span class="p">,</span>
            <span class="n">geom</span>
        <span class="k">FROM</span> <span class="n">tiles</span>
    <span class="p">)</span> <span class="n">bbox</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">muni</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">bbox</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span>
    <span class="k">JOIN</span> <span class="n">party_results_cur</span> <span class="n">prc</span> <span class="k">ON</span> <span class="p">(</span><span class="n">muni</span><span class="p">.</span><span class="n">muni_id</span> <span class="o">=</span> <span class="n">prc</span><span class="p">.</span><span class="n">muni_id</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">mvt</span> <span class="p">(</span><span class="n">mvt</span> <span class="n">bytea</span><span class="p">,</span> <span class="n">x</span> <span class="nb">integer</span><span class="p">,</span> <span class="n">y</span> <span class="nb">integer</span><span class="p">,</span> <span class="n">z</span> <span class="nb">integer</span><span class="p">);</span>
<span class="k">DO</span>
<span class="err">$$</span>
<span class="k">DECLARE</span> <span class="n">r</span> <span class="n">record</span><span class="p">;</span>
<span class="k">BEGIN</span>
<span class="k">FOR</span> <span class="n">r</span> <span class="k">in</span> <span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="k">FROM</span> <span class="n">tmp_tiles</span> <span class="n">LOOP</span>
    <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">mvt</span>
    <span class="k">SELECT</span> <span class="n">ST_AsMVT</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s1">&#39;municipality&#39;</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="s1">&#39;geom&#39;</span><span class="p">),</span> <span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">z</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">muni_id</span><span class="p">,</span>
            <span class="k">data</span><span class="p">,</span>
            <span class="n">geom</span>
        <span class="k">FROM</span> <span class="n">tmp_tiles</span>
        <span class="k">WHERE</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">)</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">RAISE</span> <span class="n">INFO</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
<span class="k">END</span> <span class="n">LOOP</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="err">$$</span><span class="p">;</span>
</pre></div>


<p>Once filled, the table rows can be written to the filesystem with the simple piece of Python&nbsp;code.</p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">text</span>

<span class="n">CACHE_PATH</span><span class="o">=</span><span class="s2">&quot;cache/&quot;</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;postgresql:///&#39;</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="n">sql</span><span class="o">=</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;SELECT mvt, x, y, z FROM mvt&quot;</span><span class="p">)</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>

<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">cachefile</span> <span class="o">=</span> <span class="s2">&quot;{}/{}/{}/{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">CACHE_PATH</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">cachefile</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;{}/{}/{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">CACHE_PATH</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s2">&quot;{}/{}/{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">CACHE_PATH</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cachefile</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>


<h2>Conclusion</h2>
<p>PostGIS is a brilliant tool for generating Mapbox vector tiles. Combined with Python powered static file generator and Nginx, it seems to become the only tool needed to get you&nbsp;going.</p>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2017/postgis-as-a-mapbox-vector-tiles-generator/" rel="bookmark" title="Permalink to PostGIS as a Mapbox Vector Tiles generator">PostGIS as a Mapbox Vector Tiles&nbsp;generator</a></h1>
    <aside><span>Aug 6, 2017</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/docker.html">docker</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/javascript.html">javascript</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p><a href="http://postgis.net/2017/08/05/postgis-2.4.0alpha/">PostGIS 2.4.0</a> was released recently bringing the possibilities to generate <strong>Mapbox Vector Tiles</strong> without any third party tools. I got a shot at it with Node.js and docker. Even if it&#8217;s not as straightforward as solely using <a href="https://postgis.net/docs/manual-dev/ST_AsMVT.html">ST_AsMVT</a>, it still looks pretty&nbsp;great.</p>
<h2>Docker&nbsp;container</h2>
<p>There are no Ubuntu or Debian based PostGIS 2.4.0 packages as far as I know. As installation from source (especially considering <span class="caps">GIS</span> software) is always a bit risky, I prefer using Docker to stay away from trouble. The image is based on Ubuntu 17.04, has PostgreSQL 9.6 and PostGIS 2.4.0 installed. It exposes port 5432 to the host, so you can access the database from the outside the&nbsp;container.</p>
<div class="highlight"><pre><span></span>FROM ubuntu:17.04
RUN apt update
RUN apt install -y wget less systemd
RUN touch /etc/apt/sources.list.d/pgdg.list
RUN <span class="nb">echo</span> <span class="s2">&quot;deb http://apt.postgresql.org/pub/repos/apt/ zesty-pgdg main&quot;</span> <span class="p">&amp;</span>gt<span class="p">;</span> /etc/apt/sources.list.d/pgdg.list
RUN wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc <span class="p">|</span> apt-key add -
RUN apt update
RUN apt -y install postgresql-9.6 postgresql-server-dev-9.6

USER postgres
RUN /usr/lib/postgresql/9.6/bin/pg_ctl -D /var/lib/postgresql/9.6/main -l /tmp/logfile start

USER root
RUN <span class="nb">echo</span> <span class="s2">&quot;host all  all    0.0.0.0/0  trust&quot;</span> <span class="p">&amp;</span>gt<span class="p">;&amp;</span>gt<span class="p">;</span> /etc/postgresql/9.6/main/pg_hba.conf <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> <span class="se">\</span>
    <span class="nb">echo</span> <span class="s2">&quot;listen_addresses=&#39;*&#39;&quot;</span> <span class="p">&amp;</span>gt<span class="p">;&amp;</span>gt<span class="p">;</span> /etc/postgresql/9.6/main/postgresql.conf


EXPOSE <span class="m">5432</span>
RUN apt install -y netcat build-essential libxml2 libxml2-dev libgeos-3.5.1 libgdal-dev gdal-bin libgdal20 libgeos-dev libprotobuf-c1 libprotobuf-c-dev libprotobuf-dev protobuf-compiler protobuf-c-compiler
RUN wget http://download.osgeo.org/postgis/source/postgis-2.4.0alpha.tar.gz
RUN tar -xvzf postgis-2.4.0alpha.tar.gz
RUN <span class="nb">cd</span> postgis-2.4.0alpha <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> ./configure <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> make install

USER postgres
RUN service postgresql start <span class="p">&amp;</span>amp<span class="p">;&amp;</span>amp<span class="p">;</span> psql -c <span class="s2">&quot;CREATE EXTENSION postgis&quot;</span>

USER root
COPY start.postgis.sh /start.postgis.sh
RUN chmod <span class="m">0755</span> /start.postgis.sh

CMD <span class="o">[</span><span class="s2">&quot;/start.postgis.sh&quot;</span><span class="o">]</span>
</pre></div>


<p><code>start.postgis.sh</code> file starts the database server and keeps it running&nbsp;forever.</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="nv">DATADIR</span><span class="o">=</span><span class="s2">&quot;/var/lib/postgresql/9.6/main&quot;</span>
<span class="nv">CONF</span><span class="o">=</span><span class="s2">&quot;/etc/postgresql/9.6/main/postgresql.conf&quot;</span>
<span class="nv">POSTGRES</span><span class="o">=</span><span class="s2">&quot;/usr/lib/postgresql/9.6/bin/postgres&quot;</span>

su postgres sh -c <span class="s2">&quot;</span><span class="nv">$POSTGRES</span><span class="s2"> -D </span><span class="nv">$DATADIR</span><span class="s2"> -c config_file=</span><span class="nv">$CONF</span><span class="s2">&quot;</span> <span class="p">&amp;</span>amp<span class="p">;</span>
<span class="k">until</span> nc -z localhost <span class="m">5432</span><span class="p">;</span>
<span class="k">do</span>
    <span class="nb">echo</span> ...
    sleep <span class="m">5</span>
<span class="k">done</span>
sleep <span class="m">5</span> <span class="c1"># just for sure</span>
su - postgres -c <span class="s2">&quot;psql -c \&quot;CREATE EXTENSION IF NOT EXISTS postgis\&quot;&quot;</span>
<span class="nb">echo</span> database up and running

<span class="nb">wait</span> <span class="nv">$!</span>
</pre></div>


<h2>Data</h2>
<p>I got a cadastre area dataset of the Czech Republic for testing, which contains ~ 13,000 polygons. The geometries should come in Web Mercator a.k.a. <span class="caps">EPSG</span>:3857 to work with <a href="https://www.mapbox.com/vector-tiles/specification/"><span class="caps">MVT</span></a>.</p>
<h2>Vector&nbsp;tiles</h2>
<p>I got a bit confused by the docs of <a href="https://postgis.net/docs/manual-dev/ST_AsMVT.html">ST_AsMVT</a> and <a href="https://postgis.net/docs/manual-dev/ST_AsMVTGeom.html">ST_AsMVTGeom</a>. Especially the latter one took me a few hours to get it right. What is essential (I guess) about Mapbox Vector Tiles is that you have to abstract from the real world coordinates and start thinking inside the tile coordinates. What PostGIS does with <code>ST_AsMVTGeom</code> (and what any other <span class="caps">MVT</span> implemenation should do for you) is that it takes real world coordinates and put them inside a&nbsp;tile.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/postgis-as-a-mapbox-vector-tiles-generator/mvt.gif"/></div>

<p>To make this work, you need to know every bounding box of every tile on every zoom level in a Web Mercator projection. Or you can use <a href="https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql">TileBBox procedure by Mapbox</a>, if you&nbsp;wish.</p>
<p>The <span class="caps">SQL</span> query itself is pretty simple (this comes from an express route I&#8217;ll be discussing&nbsp;shortly).</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">ST_AsMVT</span><span class="p">(</span><span class="s1">&#39;cadastre&#39;</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">code</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">ST_AsMVTGeom</span><span class="p">(</span>
            <span class="n">geom</span><span class="p">,</span>
            <span class="n">TileBBox</span><span class="p">(</span><span class="err">${</span><span class="n">req</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">z</span><span class="err">}</span><span class="p">,</span> <span class="err">${</span><span class="n">req</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">x</span><span class="err">}</span><span class="p">,</span> <span class="err">${</span><span class="n">req</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">y</span><span class="err">}</span><span class="p">,</span> <span class="mi">3857</span><span class="p">),</span>
            <span class="mi">4096</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="k">false</span>
        <span class="p">)</span> <span class="n">geom</span>
    <span class="k">FROM</span> <span class="n">cadastre_area</span>
    <span class="k">WHERE</span> <span class="n">ST_Intersects</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">ST_Transform</span><span class="p">(</span><span class="n">ST_MakeEnvelope</span><span class="p">(</span><span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="err">$</span><span class="mi">3</span><span class="p">,</span> <span class="err">$</span><span class="mi">4</span><span class="p">,</span> <span class="err">$</span><span class="mi">5</span><span class="p">),</span> <span class="mi">3857</span><span class="p">)))</span>
<span class="p">)</span> <span class="n">q</span>
</pre></div>


<p>When filled with proper arguments instead of placeholders, it returns a&nbsp;bytea.</p>
<div class="highlight"><pre><span></span><span class="se">\x</span>1aa5dbd0070a047465737412e216120400000101180322d7160987913f8db38e01aa59160e2a010412012a0624060e001410420a1a00203b0a3914190e15085912010a0f0c0f06370804080a0e0e0234090e0
</pre></div>


<p>This can be consumed by a Leaflet map using <a href="https://github.com/Leaflet/Leaflet.VectorGrid">Leaflet.VectorGrid plugin</a>. To keep it short, the frontend code actually boils down to three lines of&nbsp;code.</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">&#39;http://localhost:3000/mvt/{x}/{y}/{z}&#39;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">cadastre</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">vectorGrid</span><span class="p">.</span><span class="nx">protobuf</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">addLayer</span><span class="p">(</span><span class="nx">cadastre</span><span class="p">);</span>
</pre></div>


<p>The <a href="https://gist.github.com/zimmicz/9e78d9888ab73abc7e87553b77999bc8">server <span class="caps">MVP</span> is available</a> as a GitHub&nbsp;gist.</p>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2017/routing-with-pgrouting-catchment-area-calculation/" rel="bookmark" title="Permalink to Routing with pgRouting: Catchment Area Calculation">Routing with pgRouting: Catchment Area&nbsp;Calculation</a></h1>
    <aside><span>Apr 14, 2017</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/pgrouting.html">pgrouting</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p>For a long time I&#8217;ve wanted to play with <a href="http://pgrouting.org/">pgRouting</a> and that time has finally come. Among many other routing functions there is one that caught my eye, called <code>pgr_drivingdistance</code>. As the documentation says, it <em>returns the driving distance from a start node</em> using Dijkstra algorithm. The aforementioned distance doesn&#8217;t need to be defined in Euclidean space (the real distance between two points), it might be calculated in units of time, slopeness etc. How to get it&nbsp;going?</p>
<h2>Data</h2>
<p><span class="caps">OSM</span> will do as it always does. There is a tool called <code>osm2pgrouting</code> to help you load the data, the pure <span class="caps">GDAL</span> seems to be a better way to me though. Importing the downloaded data is&nbsp;trivial.</p>
<div class="highlight"><pre><span></span>ogr2ogr -f <span class="s2">&quot;PostgreSQL&quot;</span> PG:<span class="s2">&quot;dbname=pgrouting active_schema=cze&quot;</span> <span class="se">\</span>
    -s_srs EPSG:4326 <span class="se">\</span>
    -t_srs EPSG:5514 <span class="se">\</span>
    roads.shp <span class="se">\</span>
    -nln roads <span class="se">\</span>
    -lco <span class="nv">GEOMETRY_NAME</span><span class="o">=</span>the_geom <span class="se">\</span>
    -lco <span class="nv">FID</span><span class="o">=</span>id <span class="se">\</span>
    -gt <span class="m">65000</span> <span class="se">\</span>
    -nlt PROMOTE_TO_MULTI <span class="se">\</span>
    -clipsrc <span class="m">16</span>.538 <span class="m">49</span>.147 <span class="m">16</span>.699 <span class="m">49</span>.240
</pre></div>


<p>To route the network, it has to be properly noded. Although pgRouting comes with built-in <code>pgr_nodenetwork</code>, it didn&#8217;t seem to work very well. To node the network, use PostGIS <code>ST_Node</code>. <strong>Note this doesn&#8217;t consider bridges and&nbsp;tunnels.</strong></p>
<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">AS</span>
<span class="k">SELECT</span>
    <span class="p">(</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span> <span class="n">the_geom</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">ST_Node</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">ST_Union</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)</span> <span class="n">geom</span>
        <span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads</span>
    <span class="p">)</span> <span class="n">a</span>
<span class="p">)</span> <span class="n">b</span><span class="p">;</span>
</pre></div>


<p>After noding the network, all the information about speed limits and oneways is lost. If needed, it can be brought back with&nbsp;following:</p>
<div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="k">ON</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">USING</span> <span class="n">gist</span><span class="p">(</span><span class="n">the_geom</span><span class="p">);</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">maxspeed</span> <span class="nb">integer</span><span class="p">;</span>

<span class="k">UPDATE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span>
<span class="k">SET</span> <span class="n">maxspeed</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">maxspeed</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="k">ON</span> <span class="p">(</span><span class="n">rn</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">rn</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
        <span class="n">r</span><span class="p">.</span><span class="n">maxspeed</span>
    <span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="n">rn</span>
    <span class="k">JOIN</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads</span> <span class="n">r</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">rn</span><span class="p">.</span><span class="n">the_geom</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">the_geom</span><span class="p">))</span>
    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">rn</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ST_Length</span><span class="p">(</span><span class="n">ST_Intersection</span><span class="p">(</span><span class="n">rn</span><span class="p">.</span><span class="n">the_geom</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">the_geom</span><span class="p">))</span> <span class="k">DESC</span>
<span class="p">)</span> <span class="n">a</span>
<span class="k">WHERE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</pre></div>


<p>With everything set, the topology can be&nbsp;built.</p>
<div class="highlight"><pre><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="k">source</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">target</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">pgr_createTopology</span><span class="p">(</span><span class="s1">&#39;cze.roads_noded&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>


<p>This function creates the <code>cze.roads_noded_vertices_pgr</code> that contains all the extracted nodes from the&nbsp;network.</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/routing-with-pgrouting-catchment-area-calculation/nodes.png" width="70%" /></div>

<p>As already mentioned, measures other than length can be used as a distance, I chose the time to get to a given node on&nbsp;foot.</p>
<div class="highlight"><pre><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">cost_minutes</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span>
<span class="k">SET</span> <span class="n">cost_minutes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ST_Length</span><span class="p">(</span><span class="n">the_geom</span><span class="p">)</span> <span class="o">/</span> <span class="mi">83</span><span class="p">.</span><span class="mi">0</span><span class="p">)::</span><span class="nb">integer</span><span class="p">;</span> <span class="c1">-- it takes average person one minute to walk 83 meters</span>

<span class="k">UPDATE</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded</span>
<span class="k">SET</span> <span class="n">cost_minutes</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">WHERE</span> <span class="n">cost_minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<h2>Routing</h2>
<p>Now the interesting part. All the routing functions are built on what&#8217;s called <a href="http://docs.pgrouting.org/2.4/en/pgRouting-concepts.html#inner-queries"><em>inner queries</em></a> that are expected to return a certain data structure with no geometry included. As I want to see the results in <span class="caps">QGIS</span> immediately, I had to use a simple anonymous <span class="caps">PL</span>/pgSQL block that writes polygonal catchment areas to a table (consider it a proof of concept, not the final&nbsp;solution).</p>
<div class="highlight"><pre><span></span><span class="k">DROP</span> <span class="k">TABLE</span> <span class="k">IF</span> <span class="k">EXISTS</span> <span class="n">cze</span><span class="p">.</span><span class="n">temp</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">cze</span><span class="p">.</span><span class="n">temp</span> <span class="k">AS</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">roads_noded_vertices_pgr</span> <span class="n">ver</span>
<span class="k">JOIN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="o">*</span>
    <span class="k">FROM</span> <span class="n">pgr_drivingDistance</span><span class="p">(</span>
        <span class="s1">&#39;SELECT id, source, target, cost_minutes as cost, cost_minutes as reverse_cost FROM cze.roads_noded&#39;</span><span class="p">,</span>
        <span class="mi">6686</span><span class="p">,</span>
        <span class="mi">10</span><span class="p">,</span>
        <span class="k">true</span>
    <span class="p">)</span>
<span class="p">)</span><span class="n">dist</span> <span class="k">ON</span> <span class="n">ver</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">dist</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>

<span class="k">DO</span> <span class="err">$$</span>
<span class="k">DECLARE</span>
    <span class="k">c</span> <span class="nb">integer</span><span class="p">;</span>
<span class="k">BEGIN</span>
    <span class="k">DROP</span> <span class="k">TABLE</span> <span class="k">IF</span> <span class="k">EXISTS</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tmp</span> <span class="p">(</span>
        <span class="n">agg_cost</span> <span class="nb">integer</span><span class="p">,</span>
        <span class="n">geom</span> <span class="n">geometry</span><span class="p">(</span><span class="n">MULTIPOLYGON</span><span class="p">,</span> <span class="mi">5514</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">-- order by the biggest area so the polygons are not hidden beneath the bigger ones</span>
    <span class="k">FOR</span> <span class="k">c</span> <span class="k">IN</span> <span class="k">SELECT</span> <span class="n">agg_cost</span> <span class="k">FROM</span> <span class="n">cze</span><span class="p">.</span><span class="n">temp</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">agg_cost</span> <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">3</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="mi">1</span> <span class="k">DESC</span> <span class="n">LOOP</span>
        <span class="n">RAISE</span> <span class="n">INFO</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="k">c</span><span class="p">;</span>
        <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">tmp</span> <span class="p">(</span><span class="n">agg_cost</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span>
        <span class="k">SELECT</span>
            <span class="k">c</span><span class="p">,</span>
            <span class="n">ST_Multi</span><span class="p">(</span><span class="n">ST_SetSRID</span><span class="p">(</span><span class="n">pgr_pointsAsPolygon</span><span class="p">(</span>
                <span class="s1">&#39;SELECT</span>
<span class="s1">                        temp.id::integer,</span>
<span class="s1">                        ST_X(temp.the_geom)::float AS x,</span>
<span class="s1">                        ST_Y(temp.the_geom)::float AS y</span>
<span class="s1">                FROM cze.temp</span>
<span class="s1">                WHERE agg_cost = &#39;</span> <span class="o">||</span> <span class="k">c</span>
            <span class="p">),</span> <span class="mi">5514</span><span class="p">));</span>
    <span class="k">END</span> <span class="n">LOOP</span><span class="p">;</span>
<span class="k">END</span><span class="err">$$</span><span class="p">;</span>
</pre></div>


<p>Using <code>pgr_pointsAsPolygon</code> renders resulting nodes accessible in 10-minute walk in polygons, but weird looking ones. Not bad, could be better&nbsp;though.</p>
<div class="text-center"><img src="/assets/routing-with-pgrouting-catchment-area-calculation/area1.png" width="70%" /></div>

<p>How about seeing only nodes instead of&nbsp;polygons?</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">agg_cost</span><span class="p">,</span>
    <span class="n">ST_PointN</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">agg_cost</span><span class="p">,</span>
        <span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span><span class="p">,</span>
        <span class="n">generate_series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ST_NumPoints</span><span class="p">(</span><span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)))</span> <span class="n">i</span>
    <span class="k">FROM</span> <span class="n">tmp</span>
<span class="p">)</span> <span class="n">a</span><span class="p">;</span>
</pre></div>


<p>Looks good, could be better&nbsp;though.</p>
<div class="text-center"><img src="/assets/routing-with-pgrouting-catchment-area-calculation/nodes1.png" width="70%" /></div>

<p>How about creating concave hulls from the extracted&nbsp;nodes?</p>
<div class="highlight"><pre><span></span><span class="k">SELECT</span>
    <span class="n">agg_cost</span><span class="p">,</span>
    <span class="n">ST_ConcaveHull</span><span class="p">(</span><span class="n">ST_Union</span><span class="p">(</span><span class="n">geom</span><span class="p">))</span> <span class="n">geom</span>
<span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
        <span class="n">agg_cost</span><span class="p">,</span>
        <span class="n">ST_PointN</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="n">geom</span>
    <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">agg_cost</span><span class="p">,</span>
            <span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)</span> <span class="n">geom</span><span class="p">,</span>
            <span class="n">generate_series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ST_NumPoints</span><span class="p">(</span><span class="n">ST_ExteriorRing</span><span class="p">((</span><span class="n">ST_Dump</span><span class="p">(</span><span class="n">geom</span><span class="p">)).</span><span class="n">geom</span><span class="p">)))</span> <span class="n">i</span>
        <span class="k">FROM</span> <span class="n">tmp</span>
    <span class="p">)</span> <span class="n">a</span>
<span class="p">)</span> <span class="n">b</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">agg_cost</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">agg_cost</span> <span class="k">DESC</span><span class="p">;</span>
</pre></div>


<p>This one looks the best I&nbsp;guess.</p>
<div class="text-center"><img src="/assets/routing-with-pgrouting-catchment-area-calculation/area2.png" width="70%" /></div>

<h2>Remarks</h2>
<ul>
<li>The documentation doesn&#8217;t help&nbsp;much.</li>
<li>I&#8217;d expect existing functions to return different data structures to be easy-to-use,&nbsp;actually.</li>
<li><code>LATERAL</code> might be really handy with those inner queries, have to give it a shot in the&nbsp;future.</li>
<li>Pedestrians usually don&#8217;t follow the road&nbsp;network.</li>
<li>Bridges and tunnels might be an&nbsp;issue.</li>
</ul>
</article>
<article>
    <h1><a href="https://www.zimmi.cz/posts/2017/subdivide-and-conquer-effective-spatial-indexes-in-postgis/" rel="bookmark" title="Permalink to Subdivide and Conquer: Effective Spatial Indexes in PostGIS">Subdivide and Conquer: Effective Spatial Indexes in&nbsp;PostGIS</a></h1>
    <aside><span>Jan 10, 2017</span>
    <span>    <a class="tag-url" href="https://www.zimmi.cz/posts/tag/sql.html">sql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgresql.html">postgresql</a>     <a class="tag-url" href="https://www.zimmi.cz/posts/tag/postgis.html">postgis</a>    </span>
    <span><a class="category-url" href="https://www.zimmi.cz/posts/category/sql.html">SQL</a></span>
    </aside>
    <p>Spatial indexes are absolutely crucial part of any spatial database and - as I tend to say quite often - only a fool would try to query spatial data without building spatial indexes&nbsp;beforehand.</p>
<p>Spatial indexes are based on bounding box comparisons, which are generally very fast. Yet, there are situations when spatial indexes don&#8217;t help much (or they don&#8217;t help as much as they could, if you&nbsp;wish).</p>
<div class="text-center"><img src="https://www.zimmi.cz/posts/assets/subdivide-and-conquer-effective-spatial-indexes-in-postgis/index.svg" /></div>

<p>Bounding box comparisons are effective with lots of small bounding boxes rather then few large ones. Why? See the picture above. The curved line (imagine it&#8217;s a pipeline for example) clearly demonstrates when the spatial index/bounding box comparison might fall short of what you&#8217;d&nbsp;expect.</p>
<p>Once the bounding box gets really big, it intersects so many other geometries&#8217; bounding boxes that the whole comparison starts to slow&nbsp;down.</p>
<p>Luckily, PostGIS 2.2 introduced a <a href="http://postgis.net/docs/ST_Subdivide.html">ST_Subdivide</a> function that can lend a helping hand in&nbsp;here.</p>
<p>Until today, we delivered the parcel geometries into our <a href="https://www.symap.cz">real estate acquisition process system</a> with the following query, that takes all the geometries from the <code>req_geom</code> table (pipelines, remember?) and intersects them with cadastral parcels. The second part of the query adds those parcels that haven&#8217;t been digitalized and were created manually by one of my&nbsp;workmates.</p>
<div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
<span class="k">SELECT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="n">par_id</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
    <span class="n">req_geom</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">JOIN</span>
    <span class="n">pargeo</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">geom</span><span class="p">))</span>
 <span class="k">UNION</span>
 <span class="k">SELECT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">a</span><span class="p">.</span><span class="n">idpar</span><span class="p">::</span><span class="nb">numeric</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
     <span class="n">req_man</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">);</span>
</pre></div>


<p>It&#8217;s a perfectly standard query that intersects several request geometries with ~20M parcels, nothing really fancy. Except that it takes 25 minutes to finish. Why? Pipelines,&nbsp;remember?</p>
<p>Yet, the query below takes only 30 seconds to finish (that&#8217;s a huge time saver considering that the whole process used to take ~40 minutes)! Why? Because the <code>ST_Subdivide</code> effectively shrinks the <code>req_geom</code> geometries until they have 50 vertices each at most. Such small geometries are perfect input for the bounding box comparison. Remember to call <code>DISTINCT</code> when using <code>ST_Subdivide</code>, you&#8217;d probably get duplicate parcel ids&nbsp;otherwise.</p>
<p>I also replaced the <code>UNION</code> with the <a href="https://www.zimmi.cz/posts/2015/postgresql-in-vs-exists/"><code>WHERE NOT EXISTS</code></a> expression, as it&#8217;s reasonable to assume that numeric ids comparison will be&nbsp;faster.</p>
<div class="highlight"><pre><span></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="k">DISTINCT</span>
    <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="n">par_id</span>
 <span class="k">FROM</span>
    <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
    <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">uid</span><span class="p">,</span>
            <span class="n">ST_Subdivide</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="n">geom</span>
        <span class="k">FROM</span>
            <span class="n">req_geom</span>
     <span class="p">)</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">JOIN</span>
     <span class="n">pargeo</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">ST_Intersects</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">geom</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">geom</span><span class="p">));</span>

 <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">requested_parcels</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">par_id</span><span class="p">)</span>
 <span class="k">SELECT</span>
     <span class="n">reqs</span><span class="p">.</span><span class="n">uid</span><span class="p">,</span>
     <span class="n">a</span><span class="p">.</span><span class="n">idpar</span><span class="p">::</span><span class="nb">numeric</span>
 <span class="k">FROM</span>
     <span class="n">running_requests</span> <span class="n">reqs</span>
 <span class="k">JOIN</span>
     <span class="n">req_man</span> <span class="n">a</span> <span class="k">ON</span> <span class="p">(</span><span class="n">reqs</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">uid</span><span class="p">)</span>
 <span class="k">WHERE</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="p">(</span>
     <span class="k">SELECT</span> <span class="mi">1</span>
     <span class="k">FROM</span> <span class="n">pozadovane_parcely</span> <span class="n">pp</span>
     <span class="k">WHERE</span> <span class="n">pp</span><span class="p">.</span><span class="n">par_id</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">idpar</span>
  <span class="p">);</span>
</pre></div>
</article>
<aside id="pagination">
            <a href="https://www.zimmi.cz/posts/tag/postgis2.html">Next page &raquo;</a>
</aside>    </main>
    <footer>
        Written by <a href="//www.zimmi.cz">Michal Zimmermann</a>.
        Proudly powered by <a href="//getpelican.com/">Pelican</a>,
        which takes great advantage of <a href="//python.org">Python</a>.
    </footer>
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-43432739-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-43432739-2');
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NW8R37N');</script>
<!-- End Google Tag Manager -->
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NW8R37N"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
</body>
</html>